{"meta":{"title":"tomfriwel's blog","subtitle":null,"description":null,"author":"tomfriwel","url":"https://tomfriwel.github.io/blog"},"pages":[{"title":"About","date":"2018-09-19T02:08:58.694Z","updated":"2018-09-19T02:08:58.694Z","comments":true,"path":"/about/index.html","permalink":"https://tomfriwel.github.io/blog//about/index.html","excerpt":"","text":"这里是我的个人博客。 评论功能可能需要科学上网。 有什么问题也可以提交到Issue中。 关于我 项目经验 2013年开始实习前端，学习了一些前端和后端知识。jquery、php、sql, 制作过一些网宣页面、一些简单的数据库查询、前后端数据交互。 2015年底开始通过自学和同事帮助开发出了两个iOS应用和一个macOS应用。iOS：Jue.so - 觉官方应用、作品集 by JUE.SO；macOS：作品集（因为开发者账户已到期，暂时无法搜到）。涉及到本地存储、图片加载、载入本地网页并与原生代码进行交互、微信支付、分页加载、数据同步。 2016年做过一个笔记应用（未发布），涉及到利用SQLite进行本地存储、富文本编辑、自定义键盘（不是我开发）、分片上传。 2017年开始接触微信小程序，做了几个小程序，前端大部分个人完成。 2018年大部分也是微信小程序，帮一些公司做一些定制类的小程序。 补充以上项目经验里并没有列出什么具体使用框架，框架只要细心看文档都是能摸透的，本身框架的主要目的就是为了使开发变简单。 以上项目大部分前端由自己完成，后端其他成员完成。个人认为开发一个项目主要的是要先理清楚项目逻辑，就像你可以用不同的编程语言实现生成斐波那契数列的功能，如果你不知道实现的逻辑知道再多语言也没用。 具备阅读英文文档的能力。开发macOS应用的时候经常逛国外网站，主要是百度很难找到这方面的比较深入的一些知识，大多解决办法都是stackoverflow上找的，也有在上面提问和解答过一些问题。听到过一句很经典的话：面向搜索引擎开发。不过一些像图像处理、神经网络这类开发，觉得还是要有扎实的相关基础学科的知识。 项目中有问题也会主动与设计师、后端、以及合作开发的人进行沟通。一般开始一个新项目时，会跟后端一同根据设计图总结出一些主要的接口。 个人对自己的评价是：专业知识不够深入，但遇到问题能够通过学习和查找相关资料进行解决。 兴趣爱好业余时间偶尔画画（比较业余，以前学过一段时间素描，小时候也喜欢画画）；也会玩玩游戏，英雄联盟、阴阳师、一些讲故事的模拟游戏；看书，偶尔出去骑骑自行车，拍拍照，写博客，看电影。 目前逐渐把游戏时间转移到画画和看书上面去了，因为最近希望提升自己画画方面的能力，在做一些练习。（2018-9-19） Personal Website有个人使用的一些平台的链接。"},{"title":"","date":"2018-06-21T08:53:11.554Z","updated":"2018-06-21T08:53:11.554Z","comments":true,"path":"assets/js/md5.js","permalink":"https://tomfriwel.github.io/blog/assets/js/md5.js","excerpt":"","text":"/* * JavaScript MD5 * https://github.com/blueimp/JavaScript-MD5 * * Copyright 2011, Sebastian Tschan * https://blueimp.net * * Licensed under the MIT license: * https://opensource.org/licenses/MIT * * Based on * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message * Digest Algorithm, as defined in RFC 1321. * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet * Distributed under the BSD License * See http://pajhome.org.uk/crypt/md5 for more info. */ /* global define */ ; (function ($) { 'use strict' /* * Add integers, wrapping at 2^32. This uses 16-bit operations internally * to work around bugs in some JS interpreters. */ function safeAdd(x, y) { var lsw = (x & 0xffff) + (y & 0xffff) var msw = (x >> 16) + (y >> 16) + (lsw >> 16) return (msw > (32 - cnt)) } /* * These functions implement the four basic operations the algorithm uses. */ function md5cmn(q, a, b, x, s, t) { return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b) } function md5ff(a, b, c, d, x, s, t) { return md5cmn((b & c) | (~b & d), a, b, x, s, t) } function md5gg(a, b, c, d, x, s, t) { return md5cmn((b & d) | (c & ~d), a, b, x, s, t) } function md5hh(a, b, c, d, x, s, t) { return md5cmn(b ^ c ^ d, a, b, x, s, t) } function md5ii(a, b, c, d, x, s, t) { return md5cmn(c ^ (b | ~d), a, b, x, s, t) } /* * Calculate the MD5 of an array of little-endian words, and a bit length. */ function binlMD5(x, len) { /* append padding */ x[len >> 5] |= 0x80 >> 9 > 5] >>> (i % 32)) & 0xff) } return output } /* * Convert a raw string to an array of little-endian words * Characters >255 have their high-byte silently ignored. */ function rstr2binl(input) { var i var output = [] output[(input.length >> 2) - 1] = undefined for (i = 0; i < output.length; i += 1) { output[i] = 0 } var length8 = input.length * 8 for (i = 0; i < length8; i += 8) { output[i >> 5] |= (input.charCodeAt(i / 8) & 0xff) 16) { bkey = binlMD5(bkey, key.length * 8) } for (i = 0; i < 16; i += 1) { ipad[i] = bkey[i] ^ 0x36363636 opad[i] = bkey[i] ^ 0x5c5c5c5c } hash = binlMD5(ipad.concat(rstr2binl(data)), 512 + data.length * 8) return binl2rstr(binlMD5(opad.concat(hash), 512 + 128)) } /* * Convert a raw string to a hex string */ function rstr2hex(input) { var hexTab = '0123456789abcdef' var output = '' var x var i for (i = 0; i < input.length; i += 1) { x = input.charCodeAt(i) output += hexTab.charAt((x >>> 4) & 0x0f) + hexTab.charAt(x & 0x0f) } return output } /* * Encode a string as utf-8 */ function str2rstrUTF8(input) { return unescape(encodeURIComponent(input)) } /* * Take string arguments and return either raw or hex encoded strings */ function rawMD5(s) { return rstrMD5(str2rstrUTF8(s)) } function hexMD5(s) { return rstr2hex(rawMD5(s)) } function rawHMACMD5(k, d) { return rstrHMACMD5(str2rstrUTF8(k), str2rstrUTF8(d)) } function hexHMACMD5(k, d) { return rstr2hex(rawHMACMD5(k, d)) } function md5(string, key, raw) { if (!key) { if (!raw) { return hexMD5(string) } return rawMD5(string) } if (!raw) { return hexHMACMD5(key, string) } return rawHMACMD5(key, string) } if (typeof define === 'function' && define.amd) { define(function () { return md5 }) } else if (typeof module === 'object' && module.exports) { module.exports = md5 } else { $.md5 = md5 } })(this)"},{"title":"","date":"2018-06-21T08:53:11.568Z","updated":"2018-06-21T08:53:11.568Z","comments":true,"path":"demo/Research-on-the-web-pages-of-the-adaptive-cell-phone/demo.html","permalink":"https://tomfriwel.github.io/blog/demo/Research-on-the-web-pages-of-the-adaptive-cell-phone/demo.html","excerpt":"","text":"body { margin: 0; padding: 0; background: #ddd; overflow-x: hidden; overflow-y: scroll; } .container { width: 100%; background: #000; } Web Page Research 一位伟大的法兰克大画师与另一位伟大的法兰克大画师，一起走过一片法兰克草原，谈论着技巧和艺术。他们走着、走着，看到前方有一座森林，其中技艺更为纯熟的一位告诉另一位：“新风格的绘画需要这样一种才能，当你画了这座森林中的一棵树后，看过画的人来到这里，若他愿意的话，便可从所有树木里准确无误地找出那一棵树。” 感谢安拉，我，你们见到的这幅可怜的树画，好在不是根据这种企图画出来的。这么说不是害怕如果我是如此被画出来的话，伊斯坦布尔所有的狗都会以为我是一棵真的树，跑来往我身上撒尿，而是因为：我不想成为一棵树本身，而想成为它的意义。 window.onload = function () { // 1rpx = screenWidth / 750 // 1px = 750 / screenWidth var screenWidth = window.innerWidth var unit = screenWidth / 750 console.log(screenWidth) console.log(unit) $('.container').css({ color: '#fff', fontFamily: \"'Avenir', Helvetica, Arial, sans-serif\", paddingBottom: rpx(100) }) $('.banner').css({ position: 'relative', width: '100%', height: rpx(1334), }) $('.banner .image').css({ width: '100%', height: '100%', backgroundSize: 'cover', backgroundPosition: 'center center' }) $('.banner-title-wrap').css({ position: 'absolute', bottom: 0, width: '100%', height: rpx(257), background: '#000', opacity: 0.85, textAlign: 'center', display: 'flex', justifyContent: 'center', alignItems: 'center' }) $('.banner-title').css({ marginTop: rpx(18), fontSize: rpx(32), lineHeight: rpx(46), letterSpacing: rpx(10.5), }) $('.content').css({ marginTop: rpx(100), marginLeft: rpx(40), marginRight: rpx(40), fontSize: rpx(30) }) function rpx(n) { return (n * unit) + 'px' } }"},{"title":"","date":"2018-06-21T08:53:11.569Z","updated":"2018-06-21T08:53:11.569Z","comments":true,"path":"demo/Research-on-the-web-pages-of-the-adaptive-cell-phone/jquery.js","permalink":"https://tomfriwel.github.io/blog/demo/Research-on-the-web-pages-of-the-adaptive-cell-phone/jquery.js","excerpt":"","text":"/*! jQuery v2.0.3 | (c) 2005, 2013 jQuery Foundation, Inc. | jquery.org/license //@ sourceMappingURL=jquery.min.map */ (function(e,undefined){var t,n,r=typeof undefined,i=e.location,o=e.document,s=o.documentElement,a=e.jQuery,u=e.$,l={},c=[],p=\"2.0.3\",f=c.concat,h=c.push,d=c.slice,g=c.indexOf,m=l.toString,y=l.hasOwnProperty,v=p.trim,x=function(e,n){return new x.fn.init(e,n,t)},b=/[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source,w=/\\S+/g,T=/^(?:\\s*()[^>]*|#([\\w-]*))$/,C=/^(?:|)$/,k=/^-ms-/,N=/-([\\da-z])/gi,E=function(e,t){return t.toUpperCase()},S=function(){o.removeEventListener(\"DOMContentLoaded\",S,!1),e.removeEventListener(\"load\",S,!1),x.ready()};x.fn=x.prototype={jquery:p,constructor:x,init:function(e,t,n){var r,i;if(!e)return this;if(\"string\"==typeof e){if(r=\"\"===e.charAt(e.length-1)&&e.length>=3?[null,e,null]:T.exec(e),!r||!r[1]&&t)return!t||t.jquery?(t||n).find(e):this.constructor(t).find(e);if(r[1]){if(t=t instanceof x?t[0]:t,x.merge(this,x.parseHTML(r[1],t&&t.nodeType?t.ownerDocument||t:o,!0)),C.test(r[1])&&x.isPlainObject(t))for(r in t)x.isFunction(this[r])?this[r](t[r]):this.attr(r,t[r]);return this}return i=o.getElementById(r[2]),i&&i.parentNode&&(this.length=1,this[0]=i),this.context=o,this.selector=e,this}return e.nodeType?(this.context=this[0]=e,this.length=1,this):x.isFunction(e)?n.ready(e):(e.selector!==undefined&&(this.selector=e.selector,this.context=e.context),x.makeArray(e,this))},selector:\"\",length:0,toArray:function(){return d.call(this)},get:function(e){return null==e?this.toArray():0>e?this[this.length+e]:this[e]},pushStack:function(e){var t=x.merge(this.constructor(),e);return t.prevObject=this,t.context=this.context,t},each:function(e,t){return x.each(this,e,t)},ready:function(e){return x.ready.promise().done(e),this},slice:function(){return this.pushStack(d.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(e){var t=this.length,n=+e+(0>e?t:0);return this.pushStack(n>=0&&t>n?[this[n]]:[])},map:function(e){return this.pushStack(x.map(this,function(t,n){return e.call(t,n,t)}))},end:function(){return this.prevObject||this.constructor(null)},push:h,sort:[].sort,splice:[].splice},x.fn.init.prototype=x.fn,x.extend=x.fn.extend=function(){var e,t,n,r,i,o,s=arguments[0]||{},a=1,u=arguments.length,l=!1;for(\"boolean\"==typeof s&&(l=s,s=arguments[1]||{},a=2),\"object\"==typeof s||x.isFunction(s)||(s={}),u===a&&(s=this,--a);u>a;a++)if(null!=(e=arguments[a]))for(t in e)n=s[t],r=e[t],s!==r&&(l&&r&&(x.isPlainObject(r)||(i=x.isArray(r)))?(i?(i=!1,o=n&&x.isArray(n)?n:[]):o=n&&x.isPlainObject(n)?n:{},s[t]=x.extend(l,o,r)):r!==undefined&&(s[t]=r));return s},x.extend({expando:\"jQuery\"+(p+Math.random()).replace(/\\D/g,\"\"),noConflict:function(t){return e.$===x&&(e.$=u),t&&e.jQuery===x&&(e.jQuery=a),x},isReady:!1,readyWait:1,holdReady:function(e){e?x.readyWait++:x.ready(!0)},ready:function(e){(e===!0?--x.readyWait:x.isReady)||(x.isReady=!0,e!==!0&&--x.readyWait>0||(n.resolveWith(o,[x]),x.fn.trigger&&x(o).trigger(\"ready\").off(\"ready\")))},isFunction:function(e){return\"function\"===x.type(e)},isArray:Array.isArray,isWindow:function(e){return null!=e&&e===e.window},isNumeric:function(e){return!isNaN(parseFloat(e))&&isFinite(e)},type:function(e){return null==e?e+\"\":\"object\"==typeof e||\"function\"==typeof e?l[m.call(e)]||\"object\":typeof e},isPlainObject:function(e){if(\"object\"!==x.type(e)||e.nodeType||x.isWindow(e))return!1;try{if(e.constructor&&!y.call(e.constructor.prototype,\"isPrototypeOf\"))return!1}catch(t){return!1}return!0},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},error:function(e){throw Error(e)},parseHTML:function(e,t,n){if(!e||\"string\"!=typeof e)return null;\"boolean\"==typeof t&&(n=t,t=!1),t=t||o;var r=C.exec(e),i=!n&&[];return r?[t.createElement(r[1])]:(r=x.buildFragment([e],t,i),i&&x(i).remove(),x.merge([],r.childNodes))},parseJSON:JSON.parse,parseXML:function(e){var t,n;if(!e||\"string\"!=typeof e)return null;try{n=new DOMParser,t=n.parseFromString(e,\"text/xml\")}catch(r){t=undefined}return(!t||t.getElementsByTagName(\"parsererror\").length)&&x.error(\"Invalid XML: \"+e),t},noop:function(){},globalEval:function(e){var t,n=eval;e=x.trim(e),e&&(1===e.indexOf(\"use strict\")?(t=o.createElement(\"script\"),t.text=e,o.head.appendChild(t).parentNode.removeChild(t)):n(e))},camelCase:function(e){return e.replace(k,\"ms-\").replace(N,E)},nodeName:function(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()},each:function(e,t,n){var r,i=0,o=e.length,s=j(e);if(n){if(s){for(;o>i;i++)if(r=t.apply(e[i],n),r===!1)break}else for(i in e)if(r=t.apply(e[i],n),r===!1)break}else if(s){for(;o>i;i++)if(r=t.call(e[i],i,e[i]),r===!1)break}else for(i in e)if(r=t.call(e[i],i,e[i]),r===!1)break;return e},trim:function(e){return null==e?\"\":v.call(e)},makeArray:function(e,t){var n=t||[];return null!=e&&(j(Object(e))?x.merge(n,\"string\"==typeof e?[e]:e):h.call(n,e)),n},inArray:function(e,t,n){return null==t?-1:g.call(t,e,n)},merge:function(e,t){var n=t.length,r=e.length,i=0;if(\"number\"==typeof n)for(;n>i;i++)e[r++]=t[i];else while(t[i]!==undefined)e[r++]=t[i++];return e.length=r,e},grep:function(e,t,n){var r,i=[],o=0,s=e.length;for(n=!!n;s>o;o++)r=!!t(e[o],o),n!==r&&i.push(e[o]);return i},map:function(e,t,n){var r,i=0,o=e.length,s=j(e),a=[];if(s)for(;o>i;i++)r=t(e[i],i,n),null!=r&&(a[a.length]=r);else for(i in e)r=t(e[i],i,n),null!=r&&(a[a.length]=r);return f.apply([],a)},guid:1,proxy:function(e,t){var n,r,i;return\"string\"==typeof t&&(n=e[t],t=e,e=n),x.isFunction(e)?(r=d.call(arguments,2),i=function(){return e.apply(t||this,r.concat(d.call(arguments)))},i.guid=e.guid=e.guid||x.guid++,i):undefined},access:function(e,t,n,r,i,o,s){var a=0,u=e.length,l=null==n;if(\"object\"===x.type(n)){i=!0;for(a in n)x.access(e,t,a,n[a],!0,o,s)}else if(r!==undefined&&(i=!0,x.isFunction(r)||(s=!0),l&&(s?(t.call(e,r),t=null):(l=t,t=function(e,t,n){return l.call(x(e),n)})),t))for(;u>a;a++)t(e[a],n,s?r:r.call(e[a],a,t(e[a],n)));return i?e:l?t.call(e):u?t(e[0],n):o},now:Date.now,swap:function(e,t,n,r){var i,o,s={};for(o in t)s[o]=e.style[o],e.style[o]=t[o];i=n.apply(e,r||[]);for(o in t)e.style[o]=s[o];return i}}),x.ready.promise=function(t){return n||(n=x.Deferred(),\"complete\"===o.readyState?setTimeout(x.ready):(o.addEventListener(\"DOMContentLoaded\",S,!1),e.addEventListener(\"load\",S,!1))),n.promise(t)},x.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"),function(e,t){l[\"[object \"+t+\"]\"]=t.toLowerCase()});function j(e){var t=e.length,n=x.type(e);return x.isWindow(e)?!1:1===e.nodeType&&t?!0:\"array\"===n||\"function\"!==n&&(0===t||\"number\"==typeof t&&t>0&&t-1 in e)}t=x(o),function(e,undefined){var t,n,r,i,o,s,a,u,l,c,p,f,h,d,g,m,y,v=\"sizzle\"+-new Date,b=e.document,w=0,T=0,C=st(),k=st(),N=st(),E=!1,S=function(e,t){return e===t?(E=!0,0):0},j=typeof undefined,D=1"}],"posts":[{"title":"微信公众号开发之上传图片（附AccessToken获取和处理）","slug":"WeChat-Official-Account-Development-Upload-Image","date":"2018-11-08T03:28:33.000Z","updated":"2018-11-08T06:14:33.310Z","comments":true,"path":"2018/11/08/WeChat-Official-Account-Development-Upload-Image/","link":"","permalink":"https://tomfriwel.github.io/blog/2018/11/08/WeChat-Official-Account-Development-Upload-Image/","excerpt":"","text":"最近看卡券功能的时候，创建卡券的时候涉及到上传图片的操作，但官方文档里面描述似乎有一点问题，在这里做一个记录。AccessToken的获取和处理放后面。 开发语言用的是PHP 7.0，使用CodeIgniter框架。 官方文档：上传卡券图片素材 上传图片请求地址说明：1HTTP请求方式: POST/FROMURL:https://api.weixin.qq.com/cgi-bin/media/uploadimg?access_token=ACCESS_TOKEN 文档里参数是buffer和access_token，但实际测试下来是不行的，后来网上搜索和查看素材管理相关信息后，发现需要\b参数为media、access_token和type。 代码如下： 1234567891011121314151617181920212223// access_token和type参数$params = [];// getAccessToken获取access_token的函数，如何获取查看官方文档$params['access_token'] = $this-&gt;getAccessToken();$params['type'] = \"image\";$url = \"https://api.weixin.qq.com/cgi-bin/media/uploadimg\";// 拼接后为 url?access_token=xxx&amp;type=image$url = $url.'?'.http_build_query($params);// 相对于网站的图片的绝对路径$filename = \"/path/sample.png\";// 图片在服务器上的真是路径，如果是前端上传的，\b可以另行获取\b，这里使用的是网站上的图片作为测试$real_path = $_SERVER['DOCUMENT_ROOT'].$filename;// 图片data$file_data = array(\"media\"=&gt; new \\CURLFile($real_path));// 发送请求$res = $this-&gt;post($url, $file_data, false);var_dump($res); 如果不出错最后返回的信息为：1234array(1) &#123; [&quot;url&quot;]=&gt; string(125) &quot;xxxxx&quot;&#125; post\b函数：12345678910111213141516171819202122232425262728293031323334private function post($url, $data = [], $json_encode=true) &#123; $curl = curl_init(); // 启动一个CURL会话 curl_setopt($curl, CURLOPT_URL, $url); // 要访问的地址 curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, false); // 对认证证书来源的检查 curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, false); // 从证书中检查SSL加密算法是否存在 curl_setopt($curl, CURLOPT_USERAGENT, $_SERVER['HTTP_USER_AGENT']); // 模拟用户使用的浏览器 if ($data != null) &#123; curl_setopt($curl, CURLOPT_POST, 1); // 发送一个常规的Post请求 // curl_setopt($curl, CURLOPT_POSTFIELDS, $data); // Post提交的数据包 if(gettype($data)===\"string\") &#123; curl_setopt($curl, CURLOPT_POSTFIELDS, $data); &#125; else &#123; if ($json_encode) &#123; curl_setopt($curl, CURLOPT_POSTFIELDS, json_encode($data, JSON_UNESCAPED_UNICODE)); &#125; else &#123; curl_setopt($curl, CURLOPT_POSTFIELDS, $data); &#125; &#125; &#125; curl_setopt($curl, CURLOPT_TIMEOUT, 300); // 设置超时限制防止死循环 curl_setopt($curl, CURLOPT_HEADER, 0); // 显示返回的Header区域内容 curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1); // 获取的信息以文件流的形式返回 $res = curl_exec($curl); // 执行操作 curl_close($curl); $data = json_decode($res, true); if($data==NULL) &#123; return $res; &#125; else &#123; return $data; &#125;&#125; json_encode为false的话，就不会进行json_encode。比如上面上传图片传入的是一个CURLFile，如果json_encode就会上传失败。 AccessToken的获取和处理官方文档：获取access_token \b官方文档中建议建立一个刷新机制，不要每次使用access_token的时候都去重新\b获取，详情请仔细阅读官方文档。 请求地址说明：12https请求方式: GEThttps://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET 参数为grant_type、appid和secret，具体信息可查看官方文档。 代码：设置cache和相关信息：123456789101112public function __construct() &#123; parent::__construct(); $this-&gt;load-&gt;driver( 'cache', array('adapter' =&gt; 'apc', 'backup' =&gt; 'file', 'key_prefix' =&gt; 'wechat_') ); // 公众号appid \b和 appsecrect $this-&gt;appid = 'xxx'; $this-&gt;secret = 'xxx';&#125; 获取accessToken：12345678910111213141516171819202122private function getAccessToken() &#123; $appid = $this-&gt;appid; $secret = $this-&gt;secret; // 设置cache key，这里是 wechat_[appid]_access_token，保存成功可以到/webpath/application/cache查看 // 如果想用其他方式保存也可以\b做相应更改 $key = $this-&gt;appid.'_access_token'; // 如果cache中\b没有accessToken或者已过期，重新获取或刷新 if (!$accessToken = $this-&gt;cache-&gt;get($key)) &#123; $url = \"https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=&#123;$appid&#125;&amp;secret=&#123;$secret&#125;\"; $res = $this-&gt;post($url); $accessToken = $res['access_token']; // 保存accessToken $this-&gt;cache-&gt;save($key, $accessToken, $res['expires_in']); &#125; return $accessToken;&#125; 参考 官方文档：上传卡券图片素材 官方文档：获取access_token PHP通过CURL上传图片（微信公众号上传素材）","categories":[],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://tomfriwel.github.io/blog/tags/微信小程序/"},{"name":"前端","slug":"前端","permalink":"https://tomfriwel.github.io/blog/tags/前端/"}]},{"title":"通过编程来学习线性代数4-行列式按行(列)展开","slug":"learn-linear-algebra-by-programming-4","date":"2018-10-14T09:59:17.000Z","updated":"2018-10-14T09:59:30.162Z","comments":true,"path":"2018/10/14/learn-linear-algebra-by-programming-4/","link":"","permalink":"https://tomfriwel.github.io/blog/2018/10/14/learn-linear-algebra-by-programming-4/","excerpt":"","text":"余子式：将aij所在的行和列划去后，剩下的元素组成的行列式，记作Mij。(i, j为下标) 代数余子式：Aij = Math.pow(-1, i+j) * Mij 行列式每一项都对应一个余子式和代数余子式，因为i, j可以唯一确定一个元素。 求i行j列的余子式：1234567891011121314151617181920212223/** * 余子式 * * @param &#123;Number&#125; i 行 * @param &#123;Number&#125; j 列 */Det.prototype.complementMinor = function (i, j) &#123; let len = this.length if (!(i &lt; len &amp;&amp; j &lt; len)) &#123; throw ('行标或列标超出范围: 0~'+(len-1)) &#125; let detArr = JSON.parse(JSON.stringify(this.array)) let newArr = [] for (let k = 0; k &lt; len; k++) &#123; if (i != k) &#123; let temp = detArr[k] temp.splice(j, 1) newArr.push(temp) &#125; &#125; return new Det(newArr)&#125; line 15~19 如果k等于i就跳过（同一行），如果不是，那就移除该行的第j个元素，并添加到新数组中。最后生成Det对象。 测试：1234567891011121314151617let det = new Det([ [1, 1, 2, 1], [1, -3, 5, 3], [0, 2, 2, 2], [1, 2, -4, 4]])let c0 = det.complementMinor(0, 0)// 输出// [-3, 5, 3]// [2, 2, 2]// [2, -4, 4]let c1 = det.complementMinor(3, 2)// 输出// [1, 1, 1]// [1, -3, 3]// [0, 2, 2] 引理：一个n阶行列式，如果其中第i行所有元素除aij外都为零，那么这行列式等于aij与它的代数余子式的乘积，即D=aijAij 测试：12345678910let det1 = new Det([ [1, 3, 2, 5], [5, -3, -1, 3], [0, 0, -2, 0], [-5, 2, 0, 4]])det1.calc() //296let c2 = det1.complementMinor(2, 2)let a0 = -2 * Math.pow(-1, 2 + 2) * c2.calc() //-2 * (-148)console.log(a0) //296 行列式按行（列）展开法则定理3 行列式等于它的任一行（列）的各元素与其对应的代数余子式乘积之和，即： 在Det对象上添加通过代数余子式来计算行列式的值的方法calcViaComplement:123456789101112131415161718/** * 通过代数余子式来计算行列式的值 * * @param &#123;Number&#125; i 行 */Det.prototype.calcViaComplement = function (i=0) &#123; let len = this.length if (!(i &lt; len)) &#123; throw ('行标或列标超出范围: 0~'+(len-1)) &#125; let sum = 0 for (let k = 0; k &lt; len; k++) &#123; let tempDet = this.complementMinor(i, k) sum += tempDet.calc() * Math.pow(-1, k + i) * this.array[i][k] &#125; return sum&#125; 这里默认以行来计算，默认第0行，可以通过计算不同行来验证：12345678910111213let det1 = new Det([ [1, 3, 2, 5], [5, -3, -1, 3], [0, 0, -2, 0], [-5, 2, 0, 4]])let res0 = det1.calc()let res1 = det1.calcViaComplement(0)let res2 = det1.calcViaComplement(2)console.log('res0=' + res0) //296console.log('res1=' + res1) //296console.log('res2=' + res2) //296 推论 行列式任一行（列）的元素与另一行（列）的对应元素的代数余子式乘积之和等于零。 相当于用j行替换掉第i行，此时有两行的对应列元素都相等，根据性质4：行列式中如果有两行（列）元素成比例，则此行列式为零，其结果为零。 代码 tomfriwel/linearAlgebraPro 参考 线性代数-同济大学(第五版)课件 [完整版]","categories":[],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://tomfriwel.github.io/blog/tags/基础知识/"},{"name":"线性代数","slug":"线性代数","permalink":"https://tomfriwel.github.io/blog/tags/线性代数/"}]},{"title":"[翻译]不同寻常的拍摄角度(更新中)","slug":"Translation-Unusual-View-Angle","date":"2018-09-30T05:44:12.000Z","updated":"2018-10-15T01:41:16.499Z","comments":true,"path":"2018/09/30/Translation-Unusual-View-Angle/","link":"","permalink":"https://tomfriwel.github.io/blog/2018/09/30/Translation-Unusual-View-Angle/","excerpt":"","text":"原文：Unusual View Angle 翻译方式：通过谷歌翻译后，做了一些更改和优化。 A view angle can be used to create compelling composition to a photo. By choosing unusual angle of view, one can create a composition that is something out of the ordinary. 我们可以通过运用拍摄的角度来使照片的构图富有吸引力。通过选择不寻常的视角进行拍摄，人们可以使构图与众不同。 You often see photos of famous sights that are photographed from the eye level and straight from in front of the sight. Many photos are taken from the most natural location and view angle which is of course logical. However, it means that many photos taken by different people from the same sight might look somewhat similar. That can be boring because the view in the photos is something that everybody sees while walking by the sight. The appeal of a photo can often be increased by choosing an unusual view angle instead of the natural one. 您经常会看到一些著名景点的照片，它们通常是从景点的正前方以从水平视角直接拍摄的。许多照片都是从最自然的位置和视角拍摄的，这当然是合乎逻辑的。 然而，这意味着不同人从同一视线拍摄的许多照片可能看起来有些相似。这会很无聊，因为照片中的景象是每个人在走过景点的时候都会看到的东西。所以我们通常可以通过选择不常见的视角来增加照片的吸引力，而不是以最常见、每个人都会看到的角度去拍摄。 Out of the OrdinaryThere are often many possibilities to choose a more compelling view angle than the usual one that everybody have already seen. The photo is usually more interesting when the chosen angle of view differs from the ordinary. Of course, the photographer needs go to a lot of trouble to achieve something different. If you take the photo from a lot lower or from a lot higher angle of view than the eye level, the chances are that the photo is something out of the ordinary. I tried this approach with picture 1. The building in the picture is Cathedral of Palma in Majorca in Spain. It’s a famous sight. I wanted to capture something unusual and chose a very low angle of view. Here you can read more about the photo in question. 通常有许多可能性来选择比每个人都已经看到的通常更具吸引力的视角。 当所选择的视角与普通视角不同时，照片通常更有趣。 当然，摄影师需要为实现不同的事情而遇到很多麻烦。 如果您从较低的视角拍摄照片或从较高的视角拍摄照片，那么照片可能会出现与众不同的情况。 我用图片1尝试了这种方法。图中的建筑是西班牙马略卡岛的帕尔马大教堂。 这是一个着名的景象。 我想捕捉一些不寻常的东西，并选择了一个非常低的视角。 在这里，您可以阅读有关相关照片的更多信息。 比起选择每个人都会看到的视角进行拍摄，以一种更有吸引力的视角拍摄往往有更多的可能性。这些通过不同平常的视角拍摄的照片也会更加有趣。","categories":[],"tags":[{"name":"翻译","slug":"翻译","permalink":"https://tomfriwel.github.io/blog/tags/翻译/"},{"name":"摄影","slug":"摄影","permalink":"https://tomfriwel.github.io/blog/tags/摄影/"},{"name":"构图","slug":"构图","permalink":"https://tomfriwel.github.io/blog/tags/构图/"}]},{"title":"[翻译]构图的忌讳","slug":"Translation-Things-to-Avoid-in-Composition","date":"2018-09-30T05:44:12.000Z","updated":"2018-09-30T06:43:42.892Z","comments":true,"path":"2018/09/30/Translation-Things-to-Avoid-in-Composition/","link":"","permalink":"https://tomfriwel.github.io/blog/2018/09/30/Translation-Things-to-Avoid-in-Composition/","excerpt":"","text":"原文：Things to Avoid in Composition 翻译方式：通过谷歌翻译后，做了一些更改和优化。如果在翻译文中有更好的建议可以告诉我。很喜欢这种以实际图片来解释相关技巧的文章，让我这种没有接受过专业摄影教育的人来说非常直观，易于理解。 人们通常喜欢使图片中的元素看上去更吸引人、更舒服。 通常人们会尝试使用那些已经被验证为有效的构图技巧或风格。 当然人们也可以通过另一个角度来进行构图。比如在构图的时候，可以考虑哪些东西是应该避免的。 在我看来，一旦找到好的构图方法，就应该检查图片是否有那些通常被认为是不好的东西。 图片边缘上的事物造成的分心通常在拍摄照片时，我们应该观察图片的边缘，查看是否存在可能会分散注意力的元素，这些元素是否把你的注意力从拍摄对象转移了过去。 图1是这种情况的一个例子。 右上角的椅子脚很突出。 它偷走了部分本应该聚集在猫身上的注意力，引导观众的目光远离照片。 图2是同一张照片的固定版本。 图2更清晰的表现出图片的主体，观察者注意力也不会被分散。 拍摄对象的背景人们应该始终关注拍摄对象的背景。 有时在主题背后有元素与主题重合，如图3所示。蝴蝶的翅膀和背景中的花重叠，好像形成一个整体。 更好的构图是使蝴蝶的背景更清晰，如图4所示。在图4中，蝴蝶的翅膀不与背景融合，主体的形状更突出。 在构图时，应该问自己是否出现了以下问题： 拍摄对象是否与背景重叠？ 主体和背景之间的对比是否足够强烈以使主体更加突出？ 主体在所选背景上看起来如何？ 分离主题和背景的一种方法是使用互补色。互补色可以很好地相互区分并相互加强。强调主题的另一种方法是使用纹理。纹理复杂的主体从质地简单的背景中脱颖而出。具有简单纹理的主体从具有复杂纹理的背景中脱颖而出。 照片中物体吻合的边缘在图5中，地平线和拍摄对象的上边缘恰好在同一条线上。通常应将边缘放置在不同位置，以避免这种边缘的吻合。图6中的情况更好。在图6中，地平线明显高于主体的边缘。当然，还应该避免主体边缘吻合照片边缘的情况。 应当避免的地方可以通过多种方式避免和消除上述的错误。第一步是在拍照时注意这些事情。当可能的错误已知时，可以使用以下方法来消除它们： 1. 改变拍摄的角度消除上述错误的最简单方法是改变角度。人们通常可以通过略微改变摄像机拍摄角度来避免这些错误。例如，可以从另一个方向或从不同的距离拍摄对象。 2. 更换拍摄场景有时可以通过改变场景来避免错误。 例如在图片1的情况下，在拍照之前可能已经更换了椅子。当然，你也得考虑你换掉之后，你的猫早就跑掉了。 3. 使用数字图像处理还可以使用数字图像处理来消除上述错误。可以裁剪照片，也可以使用克隆图章（Clone Stamp）工具修改照片。 这些照片中经常出现的小错误，通常是人们在拍摄完成后主动去查找出来的。但我们可以事先了解这些可能出现的错误，然后在拍摄时去避免它们。","categories":[],"tags":[{"name":"翻译","slug":"翻译","permalink":"https://tomfriwel.github.io/blog/tags/翻译/"},{"name":"摄影","slug":"摄影","permalink":"https://tomfriwel.github.io/blog/tags/摄影/"},{"name":"构图","slug":"构图","permalink":"https://tomfriwel.github.io/blog/tags/构图/"}]},{"title":"Following Artists","slug":"Following-Artists","date":"2018-09-18T02:38:51.000Z","updated":"2018-10-17T07:07:00.333Z","comments":true,"path":"2018/09/18/Following-Artists/","link":"","permalink":"https://tomfriwel.github.io/blog/2018/09/18/Following-Artists/","excerpt":"","text":"寺田克也金政基 Kim Jung GiHome Page Kim Jung Gi is an established artist from South Korea whose art work has attracted the international attention of millions over the last few years. He has the ability to visualize the drawing before making his marks. With mental pictures, he can draw without a photographic reference. “I observe things all the time. I don’t take references while I’m drawing, but I’m always collecting visual resources. I observe them carefully on daily basis, almost habitually. I study images of all sorts and genres, “Kim said, adding that he’s been passionate about art since he was a kid.” Since 2007, he has published three Sketchbooks which contain more than 2,200 pages of his monumental art work. 诺阿·布拉德利（Noah Bradley）ERAK NOTEERAK NOTE Home Page yasahime @JasminDarnellJasminDarnell Deviantart yasa-hime","categories":[],"tags":[{"name":"Drawing","slug":"Drawing","permalink":"https://tomfriwel.github.io/blog/tags/Drawing/"},{"name":"Painting","slug":"Painting","permalink":"https://tomfriwel.github.io/blog/tags/Painting/"},{"name":"Art","slug":"Art","permalink":"https://tomfriwel.github.io/blog/tags/Art/"}]},{"title":"微信小程序日历(含农历)","slug":"WeChat-miniapp-calendar-including-lunar-calendar","date":"2018-09-12T04:42:34.000Z","updated":"2018-09-18T08:51:33.801Z","comments":true,"path":"2018/09/12/WeChat-miniapp-calendar-including-lunar-calendar/","link":"","permalink":"https://tomfriwel.github.io/blog/2018/09/12/WeChat-miniapp-calendar-including-lunar-calendar/","excerpt":"","text":"welCalendar微信小程序日历（带农历） 声明计算农历的代码逻辑来自于overtrue/chinese-calendar，我只是将其中的PHP代码转为了javascript上能使用的版本。并且目前只保证Calendar.js中的Calendar.solar(year, month, day)方法能够正常使用。 据上面repo的文档介绍，农历计算范围为1900年至2100年公历。 截图","categories":[],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://tomfriwel.github.io/blog/tags/微信小程序/"},{"name":"前端","slug":"前端","permalink":"https://tomfriwel.github.io/blog/tags/前端/"},{"name":"开源项目","slug":"开源项目","permalink":"https://tomfriwel.github.io/blog/tags/开源项目/"}]},{"title":"通过编程来学习线性代数3-行列式的性质","slug":"learn-linear-algebra-by-programming-3","date":"2018-09-07T09:29:00.000Z","updated":"2018-10-14T06:37:24.266Z","comments":true,"path":"2018/09/07/learn-linear-algebra-by-programming-3/","link":"","permalink":"https://tomfriwel.github.io/blog/2018/09/07/learn-linear-algebra-by-programming-3/","excerpt":"","text":"行列式类在讨论行列式的一些性质之前，我先根据之前讲到的内容写一个行列式的类。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798// linera algebra determinant class// filename: det.jslet Det;(function()&#123; Det = function (array) &#123; this.array = array this.length = array.length // 阶乘，元素个数 this._itemLength = null // 保存逆序数的数组 this.inverseNumberArray = null // 保存每个项的数组 this._items = null this.itemValues = null // 是否需要重新计算 this.reCalc = false &#125; // 阶乘 Det.prototype.itemLength = function () &#123; if (this._itemLength == null) &#123; this._itemLength = factorial(this.length) &#125; return this._itemLength &#125; // 逆序数 Det.prototype.inverseNumber = function (index) &#123; if (this.inverseNumberArray == null) &#123; this.inverseNumberArray = new Array(this.itemLength()) &#125; if (this.inverseNumberArray[index] == undefined) &#123; let sum = 0 let item = this.items()[index] for (let i = 0, len = item.length; i &lt; len; i++) &#123; // 取出第i个数 let digit = item[i] // 用第i个数与第i位之后的数进行对比 for (let j = i + 1; j &lt; len; j++) &#123; if (digit &gt; item[j]) &#123; sum++ &#125; &#125; &#125; this.inverseNumberArray[index] = sum &#125; return this.inverseNumberArray[index] &#125; // 获取保存每个项的数组 Det.prototype.items = function () &#123; if (this._items == null) &#123; this._items = [] let standardIndex = [] for (let i = 0; i &lt; this.length; i++) &#123; standardIndex.push(i) &#125; generate(this.length, standardIndex, this._items) &#125; return this._items &#125; // 获取单个项的值 Det.prototype.itemValue = function (index) &#123; if (this.itemValues == null) &#123; this.itemValues = new Array(this.itemLength()) &#125; if(this.itemValues[index]==undefined || this.reCalc) &#123; let inverseCount = this.inverseNumber(index) let data = this.array let item = this.items()[index] let value = (inverseCount % 2 ? -1 : 1) for (let j = 0, n = this.length; j &lt; n; j++) &#123; value *= data[j][item[j]] &#125; this.itemValues[index] = value &#125; return this.itemValues[index] &#125; Det.prototype.calc = function () &#123; let sum = 0 for (let i = 0, len = this.itemLength(); i &lt; len; i++) &#123; sum += this.itemValue(i) &#125; console.log(this.array) console.log(sum) return sum &#125;&#125;)() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// filename util.js/** * 列举所有@param A 数组元素的排列 * * @param &#123;Number&#125; n A长度 * @param &#123;Array&#125; A 元素 * @param &#123;Array&#125; result 全部结果 */function generate(n, A, result) &#123; if (n == 1) &#123; result.push(A.slice()) &#125; else &#123; for (let i = 0; i &lt; n - 1; i++) &#123; generate(n - 1, A, result) if (n % 2 == 0) &#123; swap(A, i, n - 1) &#125; else &#123; swap(A, 0, n - 1) &#125; &#125; generate(n - 1, A, result) &#125;&#125;/** * 计算n的阶乘 * * @param &#123;Number&#125; n */function factorial(n) &#123; var result = 1 for (i = 2; i &lt;= n; i++) &#123; result *= i &#125; return result&#125;/** * 交互数组中的两个元素 * * @param &#123;Array&#125; arr * @param &#123;Number&#125; i * @param &#123;Number&#125; j */function swap(arr, i, j) &#123; var temp = arr[i] arr[i] = arr[j] arr[j] = temp return arr&#125; 基本的东西准备好了，下面我们往行列式类Det上加一些功能，即行列式的一些性质。 性质1：行列式与它的转置行列式相等行列式的转置行列式即行变成列，列变成行。 在det.js添加：1234567891011121314// 获取转置行列式Det.prototype.getTransposedDet = function () &#123; let len = this.length let newArr = new Array(len) for (let i = 0; i &lt; len; i++) &#123; if(!newArr[i]) &#123; newArr[i] = new Array(len) &#125; for (let j = 0; j &lt; len; j++) &#123; newArr[i][j] = this.array[j][i] &#125; &#125; return new Det(newArr)&#125; 测试：12345678910let det = new Det([ [2, 1, -5, 1], [1, -3, 0, -6], [0, 2, -1, 2], [1, 4, -7, 6]])det.calc() // 27let tdet = det.getTransposedDet()tdet.calc() // 27 这里可以把tdet.array打印出来，看是不是真的转置成功。 性质2：互换行列式的两行（列），行列式变号添加如下方法1234567891011121314// 互换行列式的两行（列）Det.prototype.swap = function (n0, n1, isRow=true) &#123; let newArr = JSON.parse(JSON.stringify(this.array)) if(isRow) &#123; newArr = swap(newArr, n0, n1) &#125; else &#123; let len = this.length for (let i = 0; i &lt; len; i++) &#123; newArr[i] = swap(newArr[i], n0, n1) &#125; &#125; return new Det(newArr)&#125; 测试：1234567891011let det = new Det([ [2, 1, -5, 1], [1, -3, 0, -6], [0, 2, -1, 2], [1, 4, -7, 6]])det.calc() // 27let tdet = det.swap(3, 1, true) // -27// let tdet = det.swap(3, 1, false) // -27tdet.calc() 性质3：行列式的某一行（列）中所有元素都乘以同一个数k，等于用数k乘以此行列式添加方法：1234567891011121314151617181920212223// 某一行（列）乘以一个数/** * * @param &#123;Number&#125; n 行/列，从0开始 * @param &#123;Number&#125; k 数 * @param &#123;Boolean&#125; isRow 默认行 */Det.prototype.multiply = function (n, k, isRow = true) &#123; let newArr = JSON.parse(JSON.stringify(this.array)) //deep copy let len = this.length if (isRow) &#123; for (let i = 0; i &lt; len; i++) &#123; newArr[n][i] *= k &#125; &#125; else &#123; for (let i = 0; i &lt; len; i++) &#123; newArr[i][n] *= k &#125; &#125; return new Det(newArr)&#125; 通过计算乘之前和之后的两个结果来看：123456789let det = new Det([ [2, 1, -5, 1], [1, -3, 0, -6], [0, 2, -1, 2], [1, 4, -7, 6]])det.calc() // 27det.multiply(1, 5).calc() // 135 也可以通过计算下面两个行列式来验证，第二个行列式的第一列是第一个行列式第一列的两倍，计算结果分别为27和54 123456789101112131415let det = new Det([ [2, 1, -5, 1], [1, -3, 0, -6], [0, 2, -1, 2], [1, 4, -7, 6]])det.calc() // 27let det2 = new Det([ [4, 1, -5, 1], [2, -3, 0, -6], [0, 2, -1, 2], [2, 4, -7, 6]])det2.calc() // 54 性质4：行列式中如果有两行（列）元素成比例，则此行列式为零可通过计算下面行列式验证：123456789101112131415let det = new Det([ [2, 1, -5, 1], //1 [1, -3, 0, -6], [0, 2, -1, 2], [4, 2, -10, 2] //2*k])det.calc() // 0let det2 = new Det([ [2, 1, -5, 1], //1 [1, -3, 0, -6], [0, 2, -1, 2], [2, 1, -5, 1] //1])det2.calc() // 0 性质5：若行列式的某一行（列）的元素都是两个数之和，如： 1234567891011121314151617181920212223let det = new Det([ [2 + 3, 1, 2, 1], [1 + 4, -3, 5, -6], [0 - 5, 2, 2, 2], [4 + 1, 2, -4, 4]])det.calc() //80let det2 = new Det([ [2, 1, 2, 1], [1, -3, 5, -6], [0, 2, 2, 2], [4, 2, -4, 4]])det2.calc() //36let det3 = new Det([ [3, 1, 2, 1], [4, -3, 5, -6], [-5, 2, 2, 2], [1, 2, -4, 4]])det3.calc() //44 性质6：把行列式的某一行（列）的各元素乘以同一个倍数加到另一行（列）对应的元素上去，行列式不变。 在Det类上添加方法123456789101112131415161718192021222324252627// 性质6：把行列式的某一行（列）的各元素乘以同一个倍数加到另一行（列）对应的元素上去，行列式不变。/** * * @param &#123;Number&#125; n0 行/列 * @param &#123;Number&#125; n1 行/列 * @param &#123;Number&#125; k 行列式的 n0(行/列) + n1(行/列)*k * @param &#123;Boolean&#125; isRow */Det.prototype.plusLine = function (n0, n1, k, isRow=true) &#123; if(n0==n1) &#123; throw('不能加到同一行或列') &#125; let newArr = JSON.parse(JSON.stringify(this.array)) let len = this.length if (isRow) &#123; for (let i = 0; i &lt; len; i++) &#123; newArr[n0][i] += newArr[n1][i] * k &#125; &#125; else &#123; for (let i = 0; i &lt; len; i++) &#123; newArr[i][n0] += newArr[i][n1] * k &#125; &#125; return new Det(newArr)&#125; 验证：123456789101112// 性质6let det = new Det([ [1, 1, 2, 1], [1, -3, 5, 3], [0, 2, 2, 2], [1, 2, -4, 4]])det.calc() //-112// 第1列每行对应元素加上第4列每行对应元素乘3let det1 = det.plusLine(0, 3, 3, false)det1.calc() //-112 代码 tomfriwel/linearAlgebraPro 参考 线性代数-同济大学(第五版)课件 [完整版]","categories":[],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://tomfriwel.github.io/blog/tags/基础知识/"},{"name":"线性代数","slug":"线性代数","permalink":"https://tomfriwel.github.io/blog/tags/线性代数/"}]},{"title":"微信小程序滤镜工具weImageFilters","slug":"weImageFilters","date":"2018-09-06T03:25:33.000Z","updated":"2018-09-06T10:06:10.708Z","comments":true,"path":"2018/09/06/weImageFilters/","link":"","permalink":"https://tomfriwel.github.io/blog/2018/09/06/weImageFilters/","excerpt":"","text":"微信小程序图片滤镜 声明 滤镜处理的代码99.9%来自于arahaya/ImageFilters.js，我这里只是做了一些小改动，使其能在微信小程序里使用。 版本要求 基础库 1.9.0 简介最近发现一个网页上好用的滤镜库，滤镜效果有几十种，就稍微做了一些更改，使其能在微信小程序使用。 其中马赛克算是一个比较有用的功能，最后那个水波旋转的效果挺有趣的。 下面的效果图均由微信开发工具模拟器生成，并且在自己手机上也测试过，能正常使用。 有些效果会比较耗时，比如高斯模糊，对于320*320的图片有时候会有几秒处理时间。这里毕竟是手机并且相当于是在网页中进行处理，所以并不建议用来处理大图。 滤镜的参数我目前是写死的，可以根据需要修改。 代码 tomfriwel/weImageFilters效果图屏幕截图 原图 绘制在canvas中的图片（320*320） Binarize (srcImageData, threshold) 二值化, 参数:(imageData, 0.9) BoxBlur (srcImageData, hRadius, vRadius, quality) 方框模糊, 参数:(imageData, 3, 3, 2) GaussianBlur (srcImageData, strength) 高斯模糊, 参数:(imageData, 4) StackBlur (srcImageData, radius) 高斯模糊和框模糊的折衷方案, 参数:(imageData, 6) Brightness (srcImageData, brightness) 亮度调节, 参数:(imageData, 100) BrightnessContrastGimp (srcImageData, brightness, contrast) 亮度、对比度, 参数:(imageData, 26, 13) BrightnessContrastPhotoshop (srcImageData, brightness, contrast) 亮度、对比度, 参数:(imageData, 26, 13) Channels (srcImageData, channel) 单色通道，这里为 blue Channel, 参数:(imageData, 3) ColorTransformFilter (srcImageData, redMultiplier, greenMultiplier, blueMultiplier, alphaMultiplier, redOffset, greenOffset, blueOffset, alphaOffset) 颜色变换滤波器, 参数:(imageData, 2, 1, 1, 1, 38, 0, 0, 0) Desaturate (srcImageData) 冲淡 Dither (srcImageData, levels) 高频振动, 参数:(imageData, 2) Edge (srcImageData) 边缘 Emboss (srcImageData) 浮雕 Enrich (srcImageData) 丰富 Flip (srcImageData, vertical) 翻转, 参数:(imageData, 0) Gamma (srcImageData, gamma) γ, 参数:(imageData, 5) GrayScale (srcImageData) 灰度 HSLAdjustment (srcImageData, hueDelta, satDelta, lightness) HSL调节, 参数:(imageData, -23, 54, 19) Invert (srcImageData) 反色 Mosaic (srcImageData, blockSize) 马赛克，blockSize马赛克块的大小, 参数:(imageData, 10) Oil (srcImageData, range, levels) 油画效果, 参数:(imageData, 5, 62) OpacityFilter (srcImageData, opacity) 不透明度, 参数:(imageData, 123) Posterize (srcImageData, levels) 多色调分色印, 参数:(imageData, 6) Rescale (srcImageData, scale) 重新调节, 参数:(imageData, 3.2) Sepia(srcImageData) 褐色 Sharpen (srcImageData, factor) 锐化, 参数:(imageData, 9) Solarize (srcImageData) 曝光 Transpose (srcImageData) 调换 Twril (srcImageData, centerX, centerY, radius, angle, edge, smooth) 水波旋转, 参数:(imageData, 0.5, 0.5, 40, 360, 0, true) 将半径和旋转角度调节一下，参数:(imageData, 0.5, 0.5, 120, 90, 0, true)","categories":[],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://tomfriwel.github.io/blog/tags/微信小程序/"},{"name":"canvas","slug":"canvas","permalink":"https://tomfriwel.github.io/blog/tags/canvas/"},{"name":"滤镜","slug":"滤镜","permalink":"https://tomfriwel.github.io/blog/tags/滤镜/"}]},{"title":"百年孤独(One Hundred Years of Solitude)","slug":"One-Hundred-Years-of-Solitude","date":"2018-08-29T01:53:25.000Z","updated":"2018-08-29T02:00:37.576Z","comments":true,"path":"2018/08/29/One-Hundred-Years-of-Solitude/","link":"","permalink":"https://tomfriwel.github.io/blog/2018/08/29/One-Hundred-Years-of-Solitude/","excerpt":"","text":"何塞.阿尔卡蒂奥.布恩迪亚梅尔基亚德斯吉卜赛人，与何塞.阿尔卡蒂奥.布恩迪亚相识","categories":[],"tags":[{"name":"阅读","slug":"阅读","permalink":"https://tomfriwel.github.io/blog/tags/阅读/"},{"name":"阅读笔记","slug":"阅读笔记","permalink":"https://tomfriwel.github.io/blog/tags/阅读笔记/"}]},{"title":"微信公众号开发指南 - 准备工作以及AccessToken","slug":"WeChat-public-account-development-guide-Preparation","date":"2018-08-27T16:00:00.000Z","updated":"2018-08-28T09:53:27.853Z","comments":true,"path":"2018/08/28/WeChat-public-account-development-guide-Preparation/","link":"","permalink":"https://tomfriwel.github.io/blog/2018/08/28/WeChat-public-account-development-guide-Preparation/","excerpt":"","text":"开发之前 得有一台自己的服务器（我用的是阿里云服务器） 做好相关的开发配置（我用的是Apache + Python + MySql，用了Python的Webpy框架） 申请测试账号因为不是每个都有一个公众号，就算有，也不能什么测试都在上线的公众号上进行。基于安全和不影响正式环境的考虑，我们可以申请一个微信公众平台接口测试帐号来进行开发测试。 申请链接：微信公众平台接口测试帐号 只需要用自己的微信扫一扫即可申请，并且会一直保留，下次扫码进入也会保留上次的设置。 大多数接口跟正式号没什么不同，但我在开发中也遇到过有些接口有限制的地方。我开发会员卡功能的时候就遇到过，这里不过多描述，当写到具体的地方会进行相关的提醒。 配置测试号进入后，会有以下几大类： 测试号信息 包含appID和appsecret，同正式公众号管理页里开发-基本配置-公众号开发信息的开发者ID(AppID)和开发者密码(AppSecret)（需要管理员扫码生成，生成后只能重置不能查看已生成的，妥善保管），需要记录下来，后续开发会用到。 接口配置信息 包含URL和Token，虽然保存后显示有修改按钮，但我修改时是改不了的，所以配置时要注意。这里的Token是自定义的，不是access_token。 因为入门指引使用的也是Webpy，如果你也是使用这个框架，你可跟着上面的代码进行配置。 在填写上面两个参数时，需要你先配置好服务器，并做好相应的代码设置。比如根据上面入门指引，你需要把handle.py文件的token = &quot;xxxx&quot;改成你填写的Token才能配置成功，不然会显示配置失败。 JS接口安全域名 域名：自己服务器的域名，你向微信发送请求时，会验证的，如果域名不匹配是无法获取数据的。不需要天http或https前缀。可以多次修改，可以填服务器的IP地址。 测试号二维码 查看测试公众号的二维码，扫码可以进行关注，并且可以看到关注的用户列表。 模板消息接口 配置一些消息模板，后续会讲到。 体验接口权限表 这里并没有列出全部的接口，比如卡券接口，不要被此列表所迷惑。 开始开发在入门指引中，已经有比较详细的开发引导，我这里代码相关的东西大多是重复内容。 微信开发里，几乎所有接口都会涉及到一个东西：access_token，本文讲完如何获取、保存access_token就结束。 根据微信官方文档介绍:获取access_token: access_token是公众号的全局唯一接口调用凭据，公众号调用各接口时都需使用access_token。开发者需要进行妥善保存。access_token的存储至少要保留512个字符空间。access_token的有效期目前为2个小时，需定时刷新，重复获取将导致上次获取的access_token失效。 公众平台的API调用所需的access_token的使用及生成方式说明： 建议公众号开发者使用中控服务器统一获取和刷新Access_token，其他业务逻辑服务器所使用的access_token均来自于该中控服务器，不应该各自去刷新，否则容易造成冲突，导致access_token覆盖而影响业务； 目前Access_token的有效期通过返回的expire_in来传达，目前是7200秒之内的值。中控服务器需要根据这个有效时间提前去刷新新access_token。在刷新过程中，中控服务器可对外继续输出的老access_token，此时公众平台后台会保证在5分钟内，新老access_token都可用，这保证了第三方业务的平滑过渡； Access_token的有效时间可能会在未来有调整，所以中控服务器不仅需要内部定时主动刷新，还需要提供被动刷新access_token的接口，这样便于业务服务器在API调用获知access_token已超时的情况下，可以触发access_token的刷新流程。 公众号和小程序均可以使用AppID和AppSecret调用本接口来获取access_token。AppID和AppSecret可在“微信公众平台-开发-基本配置”页中获得（需要已经成为开发者，且帐号没有异常状态）。调用接口时，请登录“微信公众平台-开发-基本配置”提前将服务器IP地址添加到IP白名单中，点击查看设置方法，否则将无法调用成功。小程序无需配置IP白名单。 大概意思就是，不要每次都重复获取，要保存这个access_token，目前有效期为2小时，快过期时需要提前刷新，或者在过期后有相应的机制刷新。 因为我没找到python缓存这方面合适的库，我就自己写了一个简单的缓存类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899# coding:utf-8# filename: welCache.pyimport timeimport osimport jsondef verify_directory(dirname): \"\"\"verifies and creates a directory. tries toignore collisions with other threads and processes.\"\"\" # print(dirname) tries = 0 while not os.access(dirname, os.F_OK): try: tries += 1 os.makedirs(dirname) except: if tries &gt; 5: raiseclass WelCache(object): def __init__(self, region=None, cahceType='file', dataDir='/tmp/cache/data'): self.opts = &#123; 'cache.type': cahceType, 'cache.data_dir': dataDir, &#125; if region is None: self.region = '' else: self.region = region + '_' self.file = '' self.data = None def get(self, key): key = self.opts.get('cache.data_dir') + '/' + self.region + key self.file = key data = self._read() if data is not None and data.get('expire') &gt; time.time(): return data.get('value') else: return None def set(self, key, value, expire): key = self.opts.get('cache.data_dir') + '/' + self.region + key self.file = key self._checkfile() data = json.dumps(&#123; 'value': value, 'expire': time.time() + expire &#125;) self._save(data) def log(self, key, value): key = self.opts.get('cache.data_dir') + '/' + self.region + key self.file = key self._checkfile() data = json.dumps(&#123; 'value': value, 'time': time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime(time.time())) &#125;) self._saveLog(data + '\\n') def file_exists(self, filepath): if os.access(filepath, os.F_OK): return True return False def _ensuredir(self, filename): dirname = os.path.dirname(filename) if not os.path.exists(dirname): verify_directory(dirname) def _checkfile(self): if not self.file_exists(self.file): self._ensuredir(self.file) def _save(self, data): \"\"\"覆盖文件内容\"\"\" textfile = open(self.file, 'w') textfile.write(str(data)) textfile.close() def _saveLog(self, data): \"\"\"向文件追加内容\"\"\" textfile = open(self.file, 'a') textfile.write(str(data)) textfile.close() def _read(self): if not self.file_exists(self.file): return None textfile = open(self.file, 'r') data = textfile.read() textfile.close() try: return json.loads(data) except ValueError: return None line 22，初始化类，这里我用的文件来保存数据，默认保存在目录/tmp/cache/data下面，需要修改读写权限（我设置的777），不然无法写入。 line 34~42根据key获取缓存数据，line 39判断是否过期，过期的话返回None。 line 44~52保存数据。expire有效期（秒） 因为最近也接触过一些php框架，在php的CodeIgniter或Laravel中都有现成的方法可以使用。 Laravel:123Cache::put($key, $accessToken, $expire);Cache::get($key); CodeIgniter:123456789//在Controller的__construct中初始化$this-&gt;load-&gt;driver( 'cache', array('adapter' =&gt; 'apc', 'backup' =&gt; 'file', 'key_prefix' =&gt; 'wechat_'));//使用$this-&gt;cache-&gt;save($key, $accessToken, $expire);$this-&gt;cache-&gt;get($key); 主要就是这两个函数。然后我根据官方提供的basic.py代码进行改造： 12345678910111213141516171819202122232425262728293031323334353637# -*- coding: utf-8 -*-# # filename: basic.pyimport configimport urllibimport timeimport jsonfrom welCache import WelCacheclass Basic: def __init__(self): self.__accessToken = None self.__expiresIn = 7200 self.appId = config.wx['appId'] self.appSecret = config.wx['appSecret'] self.__key = 'wx_access_token_' + self.appId self.cache = WelCache() def __real_get_access_token(self): postUrl = (\"https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=%s&amp;secret=%s\" % (self.appId, self.appSecret)) urlResp = urllib.urlopen(postUrl) urlResp = json.loads(urlResp.read()) self.__accessToken = urlResp['access_token'] self.__expiresIn = urlResp['expires_in'] self.cache.set(self.__key, self.__accessToken, self.__expiresIn-300) return self.__accessToken def get_access_token(self): self.__accessToken = self.cache.get(self.__key) if self.__accessToken is None: self.__accessToken = self.__real_get_access_token() return self.__accessToken def get_expires_in(self): return self.__expiresIn line 16这里我把key设置为wx_access_token_[appid]，保存的路径就为/tmp/cache/data/wx_access_token_[appid] line 17初始化WelCache类。 line 19~27真正获取access_token的地方，也就是刷新。 line 29~34获取access_token，如果不存在access_token就调用__real_get_access_token进行刷新。 下面是配置文件，填上自己申请的公众号信息。 12345678910# coding:utf-8# filename: config.py# https://martin-thoma.com/configuration-files-in-python/# https://stackoverflow.com/a/5056829/6279975wx = &#123; 'token': 'xxx', 'appId': \"xxx\", 'appSecret': \"xxx\"&#125; 最后在自己的路由管理页面（我是index.py）：123456789101112131415161718# coding:utf-8# filename: index.pyimport osimport syswk_dir = os.path.dirname(os.path.realpath(__file__))sys.path.append(wk_dir)import webfrom basic import Basicclass Test: def GET(self): return Basic().get_access_token()urls = ( '/', 'Test')application = web.application(urls, globals()).wsgifunc() 最后访问自己网站即可，刷新几次也是同样的access_token，如果要看有效期是否生效，可以保存的时候设置一个几秒的过期时间。","categories":[],"tags":[{"name":"微信开发","slug":"微信开发","permalink":"https://tomfriwel.github.io/blog/tags/微信开发/"}]},{"title":"Vue Router 试探","slug":"vue-router-tutorial","date":"2018-08-17T08:40:28.000Z","updated":"2018-08-17T09:31:10.250Z","comments":true,"path":"2018/08/17/vue-router-tutorial/","link":"","permalink":"https://tomfriwel.github.io/blog/2018/08/17/vue-router-tutorial/","excerpt":"","text":"在这篇记一次VUE开发环境搭建文章中我记录了一些Vue开发环境搭建的东西，最近接触了一些关于Router的内容，在这里做一个记录和分享。 相关设置稍微理了一下结构，如图 首先我们在main.js里初始化Vue：123456789import Vue from 'vue'import App from './App.vue'import router from './routes.js'new Vue(&#123; router, el: '#app', render: h =&gt; h(App)&#125;) 在App.vue里设置router-view以便使用Router12345678910111213141516&lt;template&gt;&lt;div id=\"app\" v-cloak&gt; &lt;router-view class=\"view\" keep-alive transition transition-mode=\"out-in\"&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; components: &#123;&#125;&#125;&lt;/script&gt;&lt;style&gt;[v-cloak] &#123; display: none;&#125;&lt;/style&gt; line 3 设置router-view line 2里的v-cloak配合line 13~15保证不会在加载的时候出现带有双{}的符号。 设置router, routes.js:12345678910111213141516171819import Vue from 'vue'import Router from 'vue-router'import home from './pages/home.vue'import test from './pages/test.vue'Vue.use(Router)export default new Router(&#123; routes:[ &#123; path:'/', component:home &#125;, &#123; path:'/test', component:test &#125; ]&#125;) 这里将页面映射到相应的path上，比如/test就对应了test.vue。 使用比如我们点击后跳转到另一个页面，就可以像下面这样使用：12345678910111213141516171819202122232425262728&lt;template&gt;&lt;div&gt; &lt;div @click=\"view\"&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; msg: \"Hello tom.\" &#125;; &#125;, methods:&#123; view() &#123; this.$router.push(&#123; path: \"/test\", query: &#123; name:'tom' &#125; &#125;) &#125; &#125;&#125;&lt;/script&gt;&lt;style lang=\"scss\"&gt;&lt;/style&gt; query是传参数用的，可以在下一个页面通过this.$route.query.name获取。 可以通过this.$router.back(-1)手动返回。 这里就是我初次试探Router的内容，这些对应基本的页面来说已经够用了。 参考 Vue2+VueRouter2+webpack 构建项目实战（一）准备工作","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://tomfriwel.github.io/blog/tags/Vue/"},{"name":"Router","slug":"Router","permalink":"https://tomfriwel.github.io/blog/tags/Router/"}]},{"title":"Painting record 2018 8 16","slug":"Painting-record-2018-8-16","date":"2018-08-16T06:04:57.000Z","updated":"2018-08-16T06:14:05.726Z","comments":true,"path":"2018/08/16/Painting-record-2018-8-16/","link":"","permalink":"https://tomfriwel.github.io/blog/2018/08/16/Painting-record-2018-8-16/","excerpt":"","text":"","categories":[],"tags":[{"name":"绘画","slug":"绘画","permalink":"https://tomfriwel.github.io/blog/tags/绘画/"},{"name":"记录","slug":"记录","permalink":"https://tomfriwel.github.io/blog/tags/记录/"}]},{"title":"关于创作的感悟和时间管理","slug":"About-the-inspiration-of-creation-and-time-management","date":"2018-08-16T05:41:31.000Z","updated":"2018-08-16T06:11:29.307Z","comments":true,"path":"2018/08/16/About-the-inspiration-of-creation-and-time-management/","link":"","permalink":"https://tomfriwel.github.io/blog/2018/08/16/About-the-inspiration-of-creation-and-time-management/","excerpt":"","text":"最近读完了《宽容》，书中有下面几段话： 《宽容》笔记◆ 第二十一章 斯宾诺莎历史中的一些事情总是令我费解，其中之一便是对过去那些艺术家和作家的作品数量问题的困惑。 我们现代作家协会的成员，有打字机、录音机、秘书和自来水笔辅助，每天也才能写三四千字。而莎士比亚有好几份工作，还有一个爱唠叨骂人的妻子，就连蘸水笔也不好用，他怎么能写出三十七部剧本呢？ 西班牙无敌舰队的老兵洛浦·德·维加一生都忙忙碌碌，他从哪儿弄来那么多的墨水和纸张，写下一千八百部喜剧和五百篇文章呢？ 那个奇怪的约翰·塞巴斯蒂安·巴赫又是什么样的人呢？他的小屋里有二十个孩子吵吵闹闹，而他却有时间谱写五部清唱剧，一百九十部教堂大合唱，三部婚礼大合唱，十二支圣歌，六支庄严弥撒曲，三支小提琴协奏曲，一支双小提琴协奏曲（仅此一部就足以让他名垂千古），七部钢琴与管弦乐队协奏曲，三部两架钢琴的协奏曲，两部三架钢琴的协奏曲，三十首管弦乐乐谱，还为长笛、竖琴、风琴、提琴、法国号管写了曲子，足够让普通学生练一辈子了。这个巴赫，到底是何方神圣呢？ 还有，伦勃朗和鲁本斯在三十年中几乎每个月都创作四幅画或四幅蚀刻画，他们是怎样勤奋用功的呢？不起眼的平民安东尼奥·斯特拉迪瓦里怎样在一生中做了五百四十把小提琴、五十把大提琴和十二把中提琴呢？ 我现在不是讨论他们的头脑怎么能想出这么多的情节，听辨出所有的旋律，看出各式各样的颜色和线条的组合，选择出好的木材。我只是奇怪他们的体力怎么那么好。他们怎么能胜任呢？他们不睡觉吗？他们也不偶尔抽点时间玩玩台球吗？他们从不疲倦吗？他们难道不担心神经衰弱吗？ 我的思考看到这里，审视了现在我的状态。 虽然有许多想做的事情，但都进行得非常缓慢，玩电脑、手机占据了很大一部分时间。时间被各种零散的东西所分散，缺乏专注度和持续性。 现在慢慢的将精力转移到自己想做的事情上。自己喜欢画画，但现在逐渐意识到缺乏实践，也发现水彩画与书法之间有联系，都是对于毛笔的运用。所以，想要借练书法来达到练习对毛笔的掌握。现在开始花时间在练书法和水彩画上。 我也想要创作出属于自己的作品，这些作品有我的思想和灵魂。 我开始了我的探索之路，或者说是重新拿起放在一边的笔。","categories":[],"tags":[{"name":"思考","slug":"思考","permalink":"https://tomfriwel.github.io/blog/tags/思考/"},{"name":"阅读","slug":"阅读","permalink":"https://tomfriwel.github.io/blog/tags/阅读/"}]},{"title":"Python网络框架web.py配置","slug":"ubuntu-apache-config-webpy","date":"2018-08-14T09:09:51.000Z","updated":"2018-08-28T08:54:26.535Z","comments":true,"path":"2018/08/14/ubuntu-apache-config-webpy/","link":"","permalink":"https://tomfriwel.github.io/blog/2018/08/14/ubuntu-apache-config-webpy/","excerpt":"","text":"我服务器系统是Ubuntu，用的是Apache，Apache我已经配置过了，所以不知道如何配置的可以自行搜索相关资料。 我是根据Webpy + Apache with mod_wsgi on Ubuntu来安装的。 下面主要看一下我的Apache配置： 123456789101112131415161718192021222324252627&lt;VirtualHost *:80&gt; ServerAdmin webmaster@localhost ServerName test.example.com DocumentRoot /var/web/test.example.com WSGIScriptAlias / /var/web/test.example.com/index.py/ # the Alias directive Alias /static /var/web/test.example.com/static AddType text/html .py RewriteEngine On &lt;Directory /var/web/test.example.com&gt; Options +ExecCGI &lt;/Directory&gt; # because Alias can be used to reference resources outside docroot, you # must reference the directory with an absolute path &lt;Directory /var/web/test.example.com/static&gt; # directives to effect the static directory Options FollowSymLinks &lt;/Directory&gt; # log location ErrorLog $&#123;APACHE_LOG_DIR&#125;/test.example.com.error.log CustomLog $&#123;APACHE_LOG_DIR&#125;/test.example.com.access.log combined&lt;/VirtualHost&gt; line 5 大概意思是凡是进入test.example.com的都会经过这里，如test.example.com/test, 如test.example.com/page/123，并且在index.py中做相应的url管理。 line 8 可以直接访问的静态文件目录, 并且设置line 19~22 然后用下面的代码进行初次试探： 1234567891011121314import web# from handle import Handleweb.config.debug = Trueclass Handle: def GET(self): return 'Hello tom.'urls = ( '/test', 'Handle',)application = web.application(urls, globals()).wsgifunc() 主要的就是line 10~12，相当于路由映射的东西，将/test的请求交给Handle类来处理。一般情况下是将处理类Handle单独建一个.py文件，让后通过line 2引入。 输入网址/test进行访问，比如test.example.com/test，不出错就会看到Handle类的输出了。 有的时候改动之后可能需要重启一下Apache才会生效: $ service apache2 restart。 有的时候报错需要到报错日志里查看。/var/log/apache2/test.example.com.error.log，从这点来看，不如PHP的一些框架（CodeIgniter, Laravel）那么人性化。","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://tomfriwel.github.io/blog/tags/Python/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://tomfriwel.github.io/blog/tags/Ubuntu/"},{"name":"Apache","slug":"Apache","permalink":"https://tomfriwel.github.io/blog/tags/Apache/"},{"name":"webpy","slug":"webpy","permalink":"https://tomfriwel.github.io/blog/tags/webpy/"}]},{"title":"绘画练习记录 2018-7-1","slug":"Drawing-practice-record-2018-7-1","date":"2018-07-01T14:00:57.000Z","updated":"2018-07-01T14:07:44.851Z","comments":true,"path":"2018/07/01/Drawing-practice-record-2018-7-1/","link":"","permalink":"https://tomfriwel.github.io/blog/2018/07/01/Drawing-practice-record-2018-7-1/","excerpt":"","text":"","categories":[],"tags":[{"name":"绘画","slug":"绘画","permalink":"https://tomfriwel.github.io/blog/tags/绘画/"},{"name":"记录","slug":"记录","permalink":"https://tomfriwel.github.io/blog/tags/记录/"},{"name":"练习","slug":"练习","permalink":"https://tomfriwel.github.io/blog/tags/练习/"}]},{"title":"绘画练习记录 2018-6-19","slug":"Drawing-practice-record-2018-6-19","date":"2018-06-19T14:10:17.000Z","updated":"2018-06-21T08:53:11.448Z","comments":true,"path":"2018/06/19/Drawing-practice-record-2018-6-19/","link":"","permalink":"https://tomfriwel.github.io/blog/2018/06/19/Drawing-practice-record-2018-6-19/","excerpt":"","text":"","categories":[],"tags":[{"name":"绘画","slug":"绘画","permalink":"https://tomfriwel.github.io/blog/tags/绘画/"},{"name":"记录","slug":"记录","permalink":"https://tomfriwel.github.io/blog/tags/记录/"},{"name":"练习","slug":"练习","permalink":"https://tomfriwel.github.io/blog/tags/练习/"}]},{"title":"ubuntu apache python mysql setup","slug":"ubuntu-apache-python-mysql-setup","date":"2018-06-17T01:49:48.000Z","updated":"2018-08-14T08:55:51.768Z","comments":true,"path":"2018/06/17/ubuntu-apache-python-mysql-setup/","link":"","permalink":"https://tomfriwel.github.io/blog/2018/06/17/ubuntu-apache-python-mysql-setup/","excerpt":"","text":"Version12$ cat /etc/issue&gt; Ubuntu 14.04.2 LTS \\n \\l SetupFor I alreay install Apache and Mysql, so there is not fully setup details. Detailed configuration process in the link. How To Set Up an Apache, MySQL, and Python (LAMP) Server Without Frameworks on Ubuntu 14.04 123$ sudo rm /usr/bin/python$ sudo ln -s /usr/bin/python3 /usr/bin/python$ sudo a2dismod mpm_event 123456789perl: warning: Setting locale failed.perl: warning: Please check that your locale settings: LANGUAGE = &quot;en_US:&quot;, LC_ALL = (unset), LC_CTYPE = &quot;UTF-8&quot;, LANG = &quot;en_US.UTF-8&quot; are supported and installed on your system.perl: warning: Falling back to the standard locale (&quot;C&quot;).Module mpm_event already disabled Get rid of this warning: How to set locale?Cannot set LC_CTYPE to default locale: No such file or directory 123$ sudo apt-get install language-pack-en-base$ sudo dpkg-reconfigure locales$ export LC_ALL=&quot;en_US.UTF-8&quot; Setup Apache conf: 12345678&lt;VirtualHost *:80&gt; &lt;Directory /var/www/test&gt; Options +ExecCGI DirectoryIndex index.py &lt;/Directory&gt; AddHandler cgi-script .py ... index.py:1234#!/usr/bin/pythonprint('Content-type:text/html\\r\\n')print('hello') 12$ sudo chmod 755 /var/www/test/index.py$ sudo service apache2 restart Content of How To Set Up an Apache, MySQL, and Python (LAMP) Server Without Frameworks on Ubuntu 14.04IntroductionThis article will walk you through setting up a server with Python 3, MySQL, and Apache2, sans the help of a framework. By the end of this tutorial, you will be fully capable of launching a barebones system into production. Django is often the one-shop-stop for all things Python; it’s compatible with nearly all versions of Python, comes prepackaged with a custom server, and even features a one-click-install database. Setting up a vanilla system without this powerful tool can be tricky, but earns you invaluable insight into server structure from the ground up. This tutorial uses only package installers, namely apt-get and Pip. Package installers are simply small programs that make code installations much more convenient and manageable. Without them, maintaining libraries, modules, and other code bits can become an extremely messy business. PrerequisitesTo follow this tutorial, you will need: One Ubuntu 14.04 Droplet. A sudo non-root user, which you can set up by following this tutorial. Step 1 — Making Python 3 the DefaultIn this step, we will set Python 3 as the default for our python command. First, check your current Python version. $ python --version On a fresh Ubuntu 14.04 server, this will output: Python 2.7.6 We would like to have python run Python 3. So first, let’s remove the old 2.7 binary. $ sudo rm /usr/bin/python Next, create a symbolic link to the Python 3 binary in its place. $ sudo ln -s /usr/bin/python3 /usr/bin/python If you run python --version again, you will now see Python 3.4.0. Step 2 — Installing PipIn this section, we will install Pip, the recommended package installer for Python. First, update the system’s package index. This will ensure that old or outdated packages do not interfere with the installation. $ sudo apt-get update Pip allows us to easily manage any Python 3 package we would like to have. To install it, simply run the following: $ sudo apt-get install python3-pip For an overview of Pip, you can read this tutorial. Step 3 — Installing MySQLIn this section, we will install and configure MySQL. Installing SQL is simple: $ sudo apt-get install mysql-server Enter a strong password for the MySQL root user when prompted, and remember it, because we will need it later. The MySQL server will start once installation completes. After installation, run: mysql_secure_installationThis setup will take you through a series of self-explanatory steps. First, you’ll need to enter the root password you picked a moment ago. The first question will ask if you want to change the root password, but because you just set it, enter n. For all other questions, press ENTER to accept the default response. Python 3 requires a way to connect with MySQL, however. There are a number of options, like MySQLclient, but for the module’s simplicity, this tutorial will use pymysql. Install it using Pip: $ sudo pip3 install pymysql Step 4 — Installing Apache 2In this section, we will install Apache 2, and ensure that it recognizes Python files as executables. Install Apache using apt-get: $ sudo apt-get install apache2 Like MySQL, the Apache server will start once the installation completes. Note: After installation, several ports are open to the internet. Make sure to see the conclusion of this tutorial for resources on security. We want to place our website’s root directory in a safe location. The server is by default at /var/www/html. To keep convention, we will create a new directory for testing purposes, called test, in the same location. $ sudo mkdir /var/www/test Finally, we must register Python with Apache. To start, we disable multithreading processes. $ sudo a2dismod mpm_event Then, we give Apache explicit permission to run scripts. $ sudo a2enmod mpm_prefork cgi Next, we modify the actual Apache configuration, to explicitly declare Python files as runnable file and allow such executables. Open the configuration file using nano or your favorite text editor. $ sudo nano /etc/apache2/sites-enabled/000-default.conf Add the following right after the first line, which reads &lt;VirtualHost *:80\\&gt;. 12345&lt;Directory /var/www/test&gt; Options +ExecCGI DirectoryIndex index.py&lt;/Directory&gt;AddHandler cgi-script .py Make sure that your &lt;Directory&gt; block is nested inside the &lt;VirtualHost&gt; block, like so. Make sure to indent correctly with tabs, too. /etc/apache2/sites-enabled/000-default.conf12345678&lt;VirtualHost *:80&gt; &lt;Directory /var/www/test&gt; Options +ExecCGI DirectoryIndex index.py &lt;/Directory&gt; AddHandler cgi-script .py ... This Directory block allows us to specify how Apache treats that directory. It tells Apache that the /var/www/test directory contains executables, considers index.py to be the default file, then defines the executables. We also want to allow executables in our website directory, so we need to change the path for DocumentRoot, too. Look for the line that reads DocumentRoot /var/www/html, a few lines below the long comment at the top of the file, and modify it to read /var/www/test instead. DocumentRoot /var/www/test Your file should now resemble the following. /etc/apache2/sites-enabled/000-default.conf 123456789101112&lt;VirtualHost *:80&gt; &lt;Directory /var/www/test&gt; Options +ExecCGI DirectoryIndex index.py &lt;/Directory&gt; AddHandler cgi-script .py ... DocumentRoot /var/www/test ... Save and exit the file. To put these changes into effect, restart Apache. $ sudo service apache2 restart Note: Apache 2 may throw a warning which says about the server’s fully qualified domain name; this can be ignored as the ServerName directive has little application as of this moment. They are ultimately used to determine subdomain hosting, after the necessary records are created. If the last line of the output reads [ OK ], Apache has restarted successfully. Step 5 — Testing the Final ProductIn this section, we will confirm that individual components (Python, MySQL, and Apache) can interact with one another by creating an example webpage and database. First, let’s create a database. Log in to MySQL. You’ll need to enter the MySQL root password you set earlier. mysql -u root -pAdd an example database called example. CREATE DATABASE example; Switch to the new database. USE example; Add a table for some example data that we’ll have the Python app add. CREATE TABLE numbers (num INT, word VARCHAR(20)); Press CTRL+D to exit. For more background on SQL, you can read this MySQL tutorial. Now, create a new file for our simple Python app. $ sudo nano /var/www/test/index.py Copy and paste the following code in. The in-line comments describe what each piece of the code does. Make sure to replace the passwd value with the root MySQL password you chose earlier. 12345678910111213141516171819202122232425262728#!/usr/bin/python# Turn on debug mode.import cgitbcgitb.enable()# Print necessary headers.print(\"Content-Type: text/html\")print()# Connect to the database.import pymysqlconn = pymysql.connect( db='example', user='root', passwd='your_root_mysql_password', host='localhost')c = conn.cursor()# Insert some example data.c.execute(\"INSERT INTO numbers VALUES (1, 'One!')\")c.execute(\"INSERT INTO numbers VALUES (2, 'Two!')\")c.execute(\"INSERT INTO numbers VALUES (3, 'Three!')\")conn.commit()# Print the contents of the database.c.execute(\"SELECT * FROM numbers\")print([(r[0], r[1]) for r in c.fetchall()]) Save and exit. Next, fix permissions on the newly-created file. For more information on the three-digit permissions code, see the tutorial on Linux permissions. $ sudo chmod 755 /var/www/test/index.py Now, access your server’s by going to http://your_server_ip using your favorite browser. You should see the following: your_server_ip’&gt;http://your_server_ip [(1, &#39;One!&#39;), (2, &#39;Two!&#39;), (3, &#39;Three!&#39;)] Congratulations! Your server is now online. ConclusionYou now have a working server that can run Python 3 with a robust, SQL database. The server is now also configured for easy maintenance, via well-documented and established package installers. However, in its current state, the server is vulnerable to outsiders. Whereas elements like SSL encryption are not essential to your server’s function, they are indispensable resources for a reliable, safe server. Learn more by reading about how to configure Apache, how to create an Apache SSL certificate and how to secure your Linux server.","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://tomfriwel.github.io/blog/tags/Python/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://tomfriwel.github.io/blog/tags/Ubuntu/"},{"name":"Apache","slug":"Apache","permalink":"https://tomfriwel.github.io/blog/tags/Apache/"},{"name":"Mysql","slug":"Mysql","permalink":"https://tomfriwel.github.io/blog/tags/Mysql/"}]},{"title":"《我的名字叫红》(My Name Is Red)","slug":"My-Name-Is-Red","date":"2018-06-14T12:29:38.000Z","updated":"2018-08-29T01:54:24.901Z","comments":true,"path":"2018/06/14/My-Name-Is-Red/","link":"","permalink":"https://tomfriwel.github.io/blog/2018/06/14/My-Name-Is-Red/","excerpt":"","text":"作者：费利特·奥尔罕·帕慕克 (Ferit Orhan Pamuk)我是一棵树 一位伟大的法兰克大画师与另一位伟大的法兰克大画师，一起走过一片法兰克草原，谈论着技巧和艺术。他们走着、走着，看到前方有一座森林，其中技艺更为纯熟的一位告诉另一位：“新风格的绘画需要这样一种才能，当你画了这座森林中的一棵树后，看过画的人来到这里，若他愿意的话，便可从所有树木里准确无误地找出那一棵树。”感谢安拉，我，你们见到的这幅可怜的树画，好在不是根据这种企图画出来的。这么说不是害怕如果我是如此被画出来的话，伊斯坦布尔所有的狗都会以为我是一棵真的树，跑来往我身上撒尿，而是因为：我不想成为一棵树本身，而想成为它的意义。 ◆ 第26章 我，谢库瑞 梦有三种用途： 其一：你想要某样东西，但人们却连想都不让你想。于是你就说你是在梦里见到的，这么一来，你就说出了你所想要的东西，却好像你连想都没想过似的。 其二：你想对某人使点坏。譬如说，你想诽谤一个人，于是你就说我在梦里见到他与某某女人通奸，或者说在梦里见到有人给某某帕夏送去了一罐一罐的酒。就这样，就算人们不相信你，他们也会把你所说的这些坏话中的一部分传出去，你的目的也就达到了。 其三：你想要某样东西，但你却连自己想要什么都不知道。于是，你可以描述一个乱七八糟的梦，人们就会立刻向你解释梦的含义，告诉你应当要什么、他们可以给你什么。比如，他们会说：你需要一个丈夫、一个孩子、一栋房子……","categories":[],"tags":[{"name":"阅读","slug":"阅读","permalink":"https://tomfriwel.github.io/blog/tags/阅读/"},{"name":"阅读笔记","slug":"阅读笔记","permalink":"https://tomfriwel.github.io/blog/tags/阅读笔记/"}]},{"title":"绘画练习记录 2018-6-10","slug":"Drawing-practice-record-2018-6-10","date":"2018-06-10T13:57:29.000Z","updated":"2018-06-21T08:53:11.434Z","comments":true,"path":"2018/06/10/Drawing-practice-record-2018-6-10/","link":"","permalink":"https://tomfriwel.github.io/blog/2018/06/10/Drawing-practice-record-2018-6-10/","excerpt":"","text":"","categories":[],"tags":[{"name":"绘画","slug":"绘画","permalink":"https://tomfriwel.github.io/blog/tags/绘画/"},{"name":"记录","slug":"记录","permalink":"https://tomfriwel.github.io/blog/tags/记录/"},{"name":"练习","slug":"练习","permalink":"https://tomfriwel.github.io/blog/tags/练习/"}]},{"title":"因转折语句联想到的事","slug":"Something-that-is-associated-with-a-twist-statement","date":"2018-06-09T03:44:24.000Z","updated":"2018-06-21T08:53:11.483Z","comments":true,"path":"2018/06/09/Something-that-is-associated-with-a-twist-statement/","link":"","permalink":"https://tomfriwel.github.io/blog/2018/06/09/Something-that-is-associated-with-a-twist-statement/","excerpt":"","text":"最近在读一本书，注意到书中运用了许多转折的语句，前后反差或形成对比。 听着，谢库瑞，我的心这么告诉我，他不但外表英俊，看进他的眼里，会发现他拥有一颗孩童的心，纯真孤独：嫁给他。然而，我却给了他一封意思完全相反的信。 “有些男人钱赚得愈多反而愈小气，但你不是这样。” 若要留下来，我必须忍受这可怕的痛楚，而这却不是我这老迈的身躯可以做到的。 … 以前很讨厌语文，但是现在发现自己开始感觉到这些语言、对话的有趣。 我想大概是遇到了一个叫Ting大忽悠，虽然我跟他没什么关系，还是非常崇拜他，就像我们会崇拜一些伟大的人那样，认可并感受到他们的强大，并且会对这些人的行为或思想有所模仿。 觉得会忽悠人并不算一件坏事，你看，赵本山不就把他的拐杖、自行车卖掉了吗。靠着被人们称之为忽悠的能力卖掉了自己的东西。 我想这是一种思想引导能力，引导别人的思想前往对自己有利的方向，让他们相信你所说的，并可以对他们所困惑的事情进行开导疏通。 以前他偶尔会来公司给我们讲一些我们所困惑的事情。当他问我们一些问题的时候，我总是对这些问题有所警惕，我感受到自己内心对于被他分析这件事有所排斥。就像知道\b一个人是骗子而有所警惕。 他有一次问问了一个选择性的问题，我是因为不知道，所以直接回答了一个不知道。\b选择一边之后还会有与之相关的问题，我自然就被排除了。 ”不知道。“ 我没有真正参与到话题中。没有回答问题，也就无法更进一步进行讨论。","categories":[],"tags":[{"name":"思考","slug":"思考","permalink":"https://tomfriwel.github.io/blog/tags/思考/"}]},{"title":"关于自适应手机网页的研究","slug":"Research-on-the-web-pages-of-the-adaptive-cell-phone","date":"2018-06-08T07:59:02.000Z","updated":"2018-06-21T08:53:11.482Z","comments":true,"path":"2018/06/08/Research-on-the-web-pages-of-the-adaptive-cell-phone/","link":"","permalink":"https://tomfriwel.github.io/blog/2018/06/08/Research-on-the-web-pages-of-the-adaptive-cell-phone/","excerpt":"","text":"手机设计一般以750px宽度为标准，微信小程序就是以这样的标准来开发的，引入了一个叫rpx的相对单位。 关于rpxrpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。 设备 rpx换算px (屏幕宽度/750) px换算rpx (750/屏幕宽度) iPhone5 1rpx = 0.42px 1px = 2.34rpx iPhone6 1rpx = 0.5px 1px = 2rpx iPhone6 Plus 1rpx = 0.552px 1px = 1.81rpx 所以，在开发网页的时候也可以引入这样的概念。 1rpx = screenWidth / 750 1px = 750 / screenWidth 在CSS中的像素单位就可以用类似于rpx的单位来代替。 设置一个容器： 1234&lt;body&gt; &lt;div class='container'&gt; &lt;/div&gt;&lt;/body&gt; 1234567body &#123; margin: 0; padding: 0;&#125;.container &#123; &#125; 12345678910111213var screenWidth = window.innerWidthvar unit = screenWidth / 750function rpx(n) &#123; return (n * unit) + 'px'&#125;// jquery$('.class').css(&#123; width: rpx(750), height: rpx(1334), backgroundColor: 'pink'&#125;) 在网页浏览器的模拟器中查看，无论iPhone ...或iPhone ... Plus，屏幕都会被撑满。 点这里可以看我做的Demo 这个只能用于手机端，电脑上的话屏幕比例与手机差别很大。","categories":[],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://tomfriwel.github.io/blog/tags/微信小程序/"},{"name":"Research","slug":"Research","permalink":"https://tomfriwel.github.io/blog/tags/Research/"}]},{"title":"Memory of death","slug":"Memory-of-death","date":"2018-06-06T14:03:40.000Z","updated":"2018-06-21T08:53:11.478Z","comments":true,"path":"2018/06/06/Memory-of-death/","link":"","permalink":"https://tomfriwel.github.io/blog/2018/06/06/Memory-of-death/","excerpt":"","text":"我有三个关于死亡的记忆。 一小时候跟别人一起去一条河里游泳，那时候的我并不会游泳，所以就在浅水的地方活动。即便是浅水的地方，水位也已经到了我的颈部。然后我慢慢在水中走，开始踮起了脚。突然我脚下空了，我开始使劲挣扎，想要爬出水面呼吸，结果只是喝了更多的水。 当时的想法大概是希望有人来救我，记不太清了，最后被人拉到了浅水的地方。 那一天，我经历了两次溺水。 那一天，是自己最接近死亡的一天。 二一次上学，发现铁路边的沟里有一具尸体，大概是夜里被火车撞死的。尸体旁边还有一袋猪肉，或许是想回家跟家人吃顿好的。当时非常害怕，已经能听到火车的鸣声，我跟同学还是非常快的跑到了铁路的另一边，那种恐惧持续了一天也没消失。脑海里全是那具肤色苍白的尸体。 三在小学门口，一个人不幸被货车上掉下来的钢管砸中，躺在地上，嘴里不停地吐出血泡，他躺的地方已经有一大摊血了。他快死了，我毫不怀疑。我仿佛感受到了他的恐惧、他的无助，我开始心跳加快，大概是潜意识里知道自己又会有死的一天，那时候的我会是怎样？ 三个记忆都是小学时候，那时候还在农村生活。后来再也没有这样的记忆，我想是因为人们对死亡掩盖得厉害，不愿看到它。 最近在读《我的名字叫红》，读到 第24章 我的名字叫死亡，唤醒了脑海里关于死亡的记忆。","categories":[],"tags":[{"name":"思考","slug":"思考","permalink":"https://tomfriwel.github.io/blog/tags/思考/"}]},{"title":"绘画练习记录 2018-06-03","slug":"Drawing-practice-record-2018-6-3","date":"2018-06-03T14:40:41.000Z","updated":"2018-06-21T08:53:11.456Z","comments":true,"path":"2018/06/03/Drawing-practice-record-2018-6-3/","link":"","permalink":"https://tomfriwel.github.io/blog/2018/06/03/Drawing-practice-record-2018-6-3/","excerpt":"","text":"","categories":[],"tags":[{"name":"绘画","slug":"绘画","permalink":"https://tomfriwel.github.io/blog/tags/绘画/"},{"name":"记录","slug":"记录","permalink":"https://tomfriwel.github.io/blog/tags/记录/"},{"name":"练习","slug":"练习","permalink":"https://tomfriwel.github.io/blog/tags/练习/"}]},{"title":"通过编程来学习线性代数2-计算行列式的值","slug":"2018-05-21-learn-linear-algebra-by-programming-2","date":"2018-05-30T14:31:00.000Z","updated":"2018-08-16T07:20:36.481Z","comments":true,"path":"2018/05/30/2018-05-21-learn-linear-algebra-by-programming-2/","link":"","permalink":"https://tomfriwel.github.io/blog/2018/05/30/2018-05-21-learn-linear-algebra-by-programming-2/","excerpt":"","text":"全排列及其逆序数为了计算每一项，我们先要了解如何生成每一个相乘的项，了解什么时候是正数什么时候是负数，关于正负问题就需要了解逆序数的定义。 全排列: 将n个不同的元素排成一列 123456781 &gt; 12 &gt; 1,2 | 2,13 &gt; 1,2,3 | 1,3,2 | 2,1,3 | 2,3,1 | 3,1,2 | 3,2,1... 从排列组合的知识中可以知道: n个不同的元素, 从中选取一个放到第一位, 有n钟选法, 剩下n-1个. 继续从\b这n-1各种继续选取, 放到第二位, 有n-1钟选法. 以此类推, 直到\b选完为止. n个元素所有排列的种数: n! = n*(n-1)*...*3*2*1 这里我们用 Heap&#39;s algorithm 描述的算法来生成每一项: 1234567891011121314151617181920212223242526// Heap's algorithm/** * 列举所有@param A 数组元素的全排列(排列) * * @param &#123;Number&#125; n A长度 * @param &#123;Array&#125; A 元素 * @param &#123;Array&#125; result 全部结果 */function generate(n, A, result) &#123; if (n == 1) &#123; result.push(A.slice()) &#125; else &#123; for (let i = 0; i &lt; n - 1; i++) &#123; generate(n - 1, A, result) if (n % 2 == 0) &#123; swap(A, i, n - 1) &#125; else &#123; swap(A, 0, n - 1) &#125; &#125; generate(n - 1, A, result) &#125;&#125; 可以在浏览器的控制台中试一下, 如generate(3, [1, 2, 3], arr)或者generate(4, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;], arr), 字符数字都行，arr需要事先定义好let arr = [] 得到每一项后, 就可以进行计算逆序数了. 一个排列的逆序数决定了这一项是正或负数. 逆序： n个不同的自然数，规定从小到大为标准次序。当某两个元素的先后次序与标准次序不同时，就称这两个元素组成一个逆序 逆序数： 排列中所有逆序的总数称为此排列的逆序数 计算逆序数的方法，我是直接从第一个开始，依次跟剩下的进行对比： 1234567891011121314function calcInverseNumber(item) &#123; let sum = 0 for (let i = 0, len = item.length; i &lt; len; i++) &#123; // 取出第i个数 let digit = item[i] // 用第i个数与第i位之后的数进行对比 for (let j = i + 1; j &lt; len; j++) &#123; if (digit &gt; item[j]) &#123; sum++ &#125; &#125; &#125; return sum&#125; 到这里，生成计算中的每一项和计算每一项的逆序数的方法都有了，接下来就需要一个计算方法。这个计算方法需要传入一个行列式，然后通过generate生成相乘的每一项，再通过calcInverseNumber算出逆序数并相加得出结果。 1234567891011121314151617181920212223242526272829// 计算行列式的值/** * @param &#123;Array&#125; data 行列式数组 * */function calcDeterminantV1(data) &#123; let n = data.length let standardIndex = [] for (let i = 0; i &lt; n; i++) &#123; standardIndex.push(i) &#125; let indexArr = [] generate(n, standardIndex, indexArr) let sum = 0 for (let i = 0, len = factorial(n); i &lt; len; i++) &#123; let arr = indexArr[i] let inverseCount = calcInverseNumber(arr) let item = (inverseCount % 2 ? -1 : 1) for (let j = 0; j &lt; n; j++) &#123; item *= data[j][arr[j]] &#125; sum += item &#125; return sum&#125; line 7 获取行列式的长度line 8-11 生成一个标准排列的数组[0, 1, 2, ..., n-1]line 13-14 生成0~n-1的所有可能的排列，共n!个，indexArr有n!个长度为n的数组，这些数组的元素是0~n-1组成的一个排列。line 16-26 计算行列式data的值，函数factorial(n)为计算n!的值。line 17-24遍历indexArr数组，计算每个排列的值。line 19计算排列arr的逆序数，line 21判断逆序数inverseCount的正负（奇数为负，偶数为正）。line 22-25 使data中角标(j, arr[j])对应的数进行相乘，得到item，并追加到总数sum中。 函数factorial(n):1234567891011/** * * @param &#123;Number&#125; n */function factorial(n) &#123; var result = 1 for (i = 2; i &lt;= n; i++) &#123; result *= i &#125; return result&#125; 现在可以试试用这个方法来计算行列式的值了，比如： 123456789101112131415[[1, 0, 0],[0, 3, 0],[0, 0, 3]]// sum = 9[[1, 2, -4],[-2, 2, 1],[-3, 4, -2]]// sum = -14[[2, 1, -5, 1],[1, -3, 0, -6],[0, 2, -1, 2],[1, 4, -7, 6]]// sum = 27 目前，计算行列式的值已经告一段落了，下一节将实现一些行列式的延伸。 比如行列式按行（列）展开相关知识。 代码 tomfriwel/linearAlgebraPro","categories":[],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://tomfriwel.github.io/blog/tags/基础知识/"},{"name":"线性代数","slug":"线性代数","permalink":"https://tomfriwel.github.io/blog/tags/线性代数/"}]},{"title":"machine learning & image recognition related website","slug":"machine-learning-image-recognition-related-website","date":"2018-05-30T13:41:11.000Z","updated":"2018-06-21T08:53:11.485Z","comments":true,"path":"2018/05/30/machine-learning-image-recognition-related-website/","link":"","permalink":"https://tomfriwel.github.io/blog/2018/05/30/machine-learning-image-recognition-related-website/","excerpt":"","text":"pyimagesearch这个网站有许多有趣的实例，比如有几篇文章实现了用OpenCV将游戏机屏幕里的宠物小精灵抠出来。个人觉得非常有意思。里面也有一些深度学习和树莓派（Raspberry Pi）的内容，不过没有去细看。有兴趣的可以去了解一下。 AI Shack这个网站大多是关于图像处理的，主页大多是一些概念性的东西，当然也有tutorials。 OpenCV-Python Tutorials这个网站里面是OpenCV python实例，图片和代码相结合，直观易懂。这里面有些代码用了opencv_contrib的模块，可能需要编译安装。有一篇文章讲了用分水岭算法将挨在一起的硬币圈出来。 一篇讨论如何用OpenCV辨别圣诞树问题 Learn OpenCVTo be continue…","categories":[],"tags":[{"name":"machine learning","slug":"machine-learning","permalink":"https://tomfriwel.github.io/blog/tags/machine-learning/"},{"name":"image recognition","slug":"image-recognition","permalink":"https://tomfriwel.github.io/blog/tags/image-recognition/"}]},{"title":"第一次使用Carthage记录","slug":"2018-05-07-use-carthage-for-the-first-time","date":"2018-05-07T06:30:41.000Z","updated":"2018-06-21T08:53:11.433Z","comments":true,"path":"2018/05/07/2018-05-07-use-carthage-for-the-first-time/","link":"","permalink":"https://tomfriwel.github.io/blog/2018/05/07/2018-05-07-use-carthage-for-the-first-time/","excerpt":"","text":"准备$ brew update update [–merge] [–force]: 使用git从GitHub获取最新版本的Homebrew和所有formula，并执行任何必要的迁移。 $ brew install carthage install formula: 安装 formula 很慢，后来用科学上网后快很多。 $ carthage version \b装好后查看版本 添加库在你的\b项目根目录下创建一个名为Cartfile的文件，并添加要用的第三方库，比如使用Alamofire: project/Cartfile:1github &quot;Alamofire/Alamofire&quot; ~&gt; 4.7 $ carthage update 获取（fetch）并构建（build）您列出的每个框架。 执行命令后，Carthage 会拉取库文件进行编译，会在 project/Carthage/Build 目录下生成不同平台的Alamofire.framework文件。 Carthage 不像 Cocoapods 会自动帮你做好\b连接配置，需要手动添加，因为一个一个将*.framework文件添加到 Build Phases&gt;Link Binary With Libaries 里很麻烦， 所以这里推荐把\b相应库目录添加到 Build Settings&gt;Framework Search Paths 里，比如我使用的是iOS版，那么添加一个： 1$(PROJECT_DIR)/Carthage/Build/iOS 上面设置是看别人博客\b\b进行配置的，但是一运行，就会报错： 123dyld: Library not loaded: @rpath/Alamofire.framework/Alamofire Referenced from: /var/containers/Bundle/Application/xxx/SwiftDemo.app/SwiftDemo Reason: image not found 后来查找了这个错误，\b\b\b发现添加库到 Framework Search Paths 里只是让import的时候不报错，但要保证运行的时候不报上面那个错还需要一步。 将 Alamofire.framework 添加到 General&gt;Embedded binaries 最后就可以用官方例子试用一下了： 12345678910111213Alamofire.request(\"https://httpbin.org/get\").responseJSON &#123; response in print(\"Request: \\(String(describing: response.request))\") // original url request print(\"Response: \\(String(describing: response.response))\") // http url response print(\"Result: \\(response.result)\") // response serialization result if let json = response.result.value &#123; print(\"JSON: \\(json)\") // serialized json response &#125; if let data = response.data, let utf8Text = String(data: data, encoding: .utf8) &#123; print(\"Data: \\(utf8Text)\") // original server data as UTF8 string &#125;&#125; References Carthage/Carthage 走向Carthage Homebrew dyld: Library not loaded: @rpath/Alamofire.framework/Alamofire on my iPhone(iOS8) while debuging #101 iOS app with framework crashed on device, dyld: Library not loaded, Xcode 6 Beta","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://tomfriwel.github.io/blog/tags/iOS/"}]},{"title":"更改Gihub公开邮箱后发生的ssh错误","slug":"2018-05-07-github-ssh-error-after-change-github-account-email","date":"2018-05-07T03:42:05.000Z","updated":"2018-06-21T08:53:11.433Z","comments":true,"path":"2018/05/07/2018-05-07-github-ssh-error-after-change-github-account-email/","link":"","permalink":"https://tomfriwel.github.io/blog/2018/05/07/2018-05-07-github-ssh-error-after-change-github-account-email/","excerpt":"","text":"最近改了Github的Public email，然后在电脑上使用git\b拉取Github的库的时候，发生各种离奇的错误。 一开始查了一下，没找到什么办法，也没去管，就\b没用git clone ...，\b就直接在Github上通过zip下载。 今天打算使用Carthage，然后用carthage update安装库的时候，又看到ssh相关的报错，就开始重视。因为Carthage里面也用到类似于git Github仓库地址的相关命令。 猜测是ssh key出错，可以\b到$ cd ~/.ssh查看，发现id_rsa.pub文件最后是老的邮箱，怀疑就是这个问题。 想到最近改过Github的公开邮箱（就是Github\b个人主页那个邮箱），就联系到了一起。 根据Generating a new SSH key and adding it to the ssh-agent的方法，重新设置了ssh key，填信息部分除了邮箱那里，其他都是默认的。1234$ ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;Enter a file in which to save the key (/Users/you/.ssh/id_rsa): [Press enter]Enter passphrase (empty for no passphrase): [Type a passphrase]Enter same passphrase again: [Type passphrase again] passphrase我也是直接回车没填。 然后再使用相关git命令，就解决了。 大吉大利！ 🤪🤪🤪🤪 更新改了之后，Gitlab又不行了，出现错误：12345git@gitlab.com: Permission denied (publickey).fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists. 后来把id_rsa添加到Settings &gt; SSH Keys，才可以用。 复制命令：$ pbcopy &lt; ~/.ssh/id_rsa.pub 或者创建一个新的key：1234$ ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;Enter a file in which to save the key (/Users/you/.ssh/id_rsa): gitlab_id_rsaEnter passphrase (empty for no passphrase): [Type a passphrase]Enter same passphrase again: [Type passphrase again] 然添加：12$ ssh-add ~/.ssh/id_rsa$ ssh-add ~/.ssh/gitlab_id_rsa 最后需要建一个配置文件： 12$ cd ~/.ssh/$ touch config 然后添加：1234567891011#gitlab accountHost gitlab.com HostName gitlab.com User git IdentityFile ~/.ssh/gitlab_id_rsa#github accountHost github.com HostName github.com User git IdentityFile ~/.ssh/id_rsa 也要将gitlab_id_rsa.pub内容复制到Settings &gt; SSH Keys 参考 Generating a new SSH key and adding it to the ssh-agent GitLab and SSH keys Multiple SSH Keys settings for different github account Can I have multiple ssh keys in my .ssh folder?","categories":[],"tags":[{"name":"Github","slug":"Github","permalink":"https://tomfriwel.github.io/blog/tags/Github/"}]},{"title":"小目标","slug":"2018-05-05-small-target-2018","date":"2018-05-05T11:41:10.000Z","updated":"2018-06-21T08:53:11.432Z","comments":true,"path":"2018/05/05/2018-05-05-small-target-2018/","link":"","permalink":"https://tomfriwel.github.io/blog/2018/05/05/2018-05-05-small-target-2018/","excerpt":"","text":"每周至少练习一次画画 阅读","categories":[],"tags":[{"name":"目标","slug":"目标","permalink":"https://tomfriwel.github.io/blog/tags/目标/"}]},{"title":"关于寻找解决办法","slug":"2018-04-25-the-idea-of-finding-a-solution","date":"2018-04-25T09:27:48.000Z","updated":"2018-06-21T08:53:11.432Z","comments":true,"path":"2018/04/25/2018-04-25-the-idea-of-finding-a-solution/","link":"","permalink":"https://tomfriwel.github.io/blog/2018/04/25/2018-04-25-the-idea-of-finding-a-solution/","excerpt":"","text":"过年回家被家里郊区做家务，发生了下面这件事。 老妈叫我拨蒜，我一个一个慢慢的拨。老妈直接过来用刀全部拍碎，蒜的壳很快就掉了。 这件事让我意识到有时候考虑问题可以直接去想自己做这件事想要达到的结果，比如蒜被拍碎并不会影响味道，最终是要放到菜里的，一个一个拨是非常慢的。有点类似拨\b蛋壳，一个煮熟的蛋先全部拍碎往往更好拨。 比如在工作中，公司做的软件出了bug急需解决，这个时候往往是\b工程师排查问题的所在，但此时需要的结果是解决用户的问题，不能让用户一直等在那里。这个时候可能没办法马上找出问题\b，就需要一个临时方案。 这种思维方式是让你\b不陷入\b事实上并不重要的思考中，浪费\b时间，直接思考自己想要的结果是什么，从而去思考解决办法。 总结：首先考虑目标，然后对这个目标制定计划、思考解决办法、讨论等，最后实行。","categories":[],"tags":[{"name":"思考","slug":"思考","permalink":"https://tomfriwel.github.io/blog/tags/思考/"}]},{"title":"关于学习的目的 化繁为简","slug":"2018-04-23-about-learning","date":"2018-04-23T02:19:59.000Z","updated":"2018-06-21T08:53:11.431Z","comments":true,"path":"2018/04/23/2018-04-23-about-learning/","link":"","permalink":"https://tomfriwel.github.io/blog/2018/04/23/2018-04-23-about-learning/","excerpt":"","text":"以前拼接过视频，用的是一种很挫很烦的方法，导出还很费时间，而且拼接出来的视频占的空间比原先的\b两个视频加起来还多的多。 后来问了比较专业的人如何拼接视频，他用了一个非常简单的方法，时间也非常快。 现在想来，学习的一个目的是要把做一件事情的步骤变简单，而不是复杂化。 最近很火的抖音，主要功能是将视频和音乐进行合成。 这里对其进行一个分析：对于视频制作，如果是不了解这方面知识的人是不知道如何将视频和音乐进行合成的，但是抖音将这个功能做出来让非专业的人也能享受视频制作带来的成就感。它将这个制作过程简单化，并不需要在电脑上用专业软件进行操作，用几乎每个人都有的手机就能够完成。 题外话，对于抖音的音乐，这些音乐一般是一首歌的高潮部分，听了一次还想再听一次的那种，这可能也是玩抖音会上瘾的一个原因，我看一个视频一般会多看好几遍。 抖音能火起来，并不是因为技术有多牛逼，或者是什么人工智能、区块链种种这些总被人拿来吹嘘的技术。你能很明显看到抖音制作一个视频的核心功能是视频与音乐的合成，我想这其中用不到什么人工智能，能想到会用到的地方就是它的首页推荐，可能会根据你的关注、看哪类。关键是用对地方，而不是因为某个技术火，就非得要去用。这与最近看到的一篇关于员工被辞退的文章中一句话很相似：辞退你，与能力无关。用到这里就是：一个软件能火起来，与技术牛逼程度无关。 不过，我也还没想清楚具体原因。宣传、设计、对待产品的态度、质量把控？至少带动了人们的创作激情。看到过一篇关于现在软件会故意设计得让人上瘾，这一点使用者也是需要控制的。 还有微信，对于年轻的一代，基本上都用过QQ，但提起让老一辈的人在QQ和微信之间做选择，那么我一定会选微信。区别在哪里？为什么选微信？因为我认为微信更加简单易用，这就是它适用于各种年龄段的一个重要原因。老一辈的人没有我们这么容易接受新事物，对于互联网的了解页没那么深，所以让他们去用QQ无疑是一件很头痛的事情。 对比：微信首页直接呈现的是对话列表，QQ也是，但你点进一个对话就会发现其中的不同。而且其顶部的搜索框，微信是隐藏的，需要下拉才会呈现出来，这样做减少了首页的复杂性，显得更加简洁。 再来看第二页：联系人列表。微信是直接一个列表显示完，QQ则不同，它多了一个层级：分组，这样你想要看全部联系人时，就会比微信多点分组个数次。从这一点来看，微信更为简单、直观。 之后的一页，微信相对来说也显得干净，QQ则让人感觉混进了一些奇奇怪怪的功能。对与增加应用功能这一点，微信更为明智，把这个交给了小程序，你们想开发什么功能自己去做吧。QQ为了加功能反而变得更繁重。 所以就在想，如何将一些常用的、看似复杂的、经常用到的功能简单化？ 关键词：常用、繁琐 学习的目的是为了让一件事变得简单。 Think Different. //补充一些类似的例子","categories":[],"tags":[{"name":"思考","slug":"思考","permalink":"https://tomfriwel.github.io/blog/tags/思考/"}]},{"title":"《Florence》- 游戏推荐","slug":"2018-04-09-Florence","date":"2018-04-09T08:32:28.000Z","updated":"2018-10-15T02:23:37.654Z","comments":true,"path":"2018/04/09/2018-04-09-Florence/","link":"","permalink":"https://tomfriwel.github.io/blog/2018/04/09/2018-04-09-Florence/","excerpt":"","text":"这是一款像故事书一样游戏，你可以跟这本书进行交互来慢慢感受这段关于女生恋爱的故事。 印象深刻的一个地方是, 游戏用拼图的难易程度来表达一开始约会找不到话题、不知道说什么到后来聊得来的过程。 音乐也非常棒，跟随剧情变化。低沉的、愉悦的、 Florence iOS 下载","categories":[],"tags":[{"name":"Game","slug":"Game","permalink":"https://tomfriwel.github.io/blog/tags/Game/"}]},{"title":"微信小程序群功能开发-后端篇","slug":"2018-03-22-develop-wechat-group-miniprogram-back-end","date":"2018-03-22T10:28:49.000Z","updated":"2018-06-21T08:53:11.430Z","comments":true,"path":"2018/03/22/2018-03-22-develop-wechat-group-miniprogram-back-end/","link":"","permalink":"https://tomfriwel.github.io/blog/2018/03/22/2018-03-22-develop-wechat-group-miniprogram-back-end/","excerpt":"","text":"之前介绍过了如何在微信小程序中获取群openGId相关的流程，在这篇文章中我会使用php实现之前提到过的相关接口。解析encryptedData和iv的代码官方已经给出了php、nodejs等版本的实现，这篇主要是贴一些相关代码。 准备下载官方实例：https://mp.weixin.qq.com/debug/wxadoc/dev/demo/aes-sample.zip 在自己的代码中引入并设置相关常数：1234require_once('wxBizDataCrypt.php');$appid= '...'; //小程序 AppID$appsecret= '...'; //小程序 AppSecret 获取登录信息根据微信小程序中通过wx.login得到的code获取用户对小程序的唯一标识openid和session_key，session_key时会过期的。 当然，满足一定条件还会的到unionid，具体可以查看官方文档。UnionID机制说明 12345678function getInfoWithCode($appid, $appsecret, $code) &#123; $url = \"https://api.weixin.qq.com/sns/jscode2session?appid=\".$appid.\"&amp;secret=\".$appsecret.\"&amp;js_code=\".$code.\"&amp;grant_type=authorization_code\"; $reData = http_post($url, array()); $obj = json_decode($reData); return $obj;&#125; 解析加密信息下面函数是根据官方示例改成的： 12345678910function getDecodeEncryptedData($sessionKey, $encryptedData, $iv) &#123; $pc = new WXBizDataCrypt($appid, $sessionKey); $errCode = $pc-&gt;decryptData($encryptedData, $iv, $data ); if ($errCode == 0) &#123; return $data; &#125; else &#123; return $errCode; &#125;&#125; 最后获取post传过来的参数，进行调用获取openGId： 1234567$code = ... // post 参数$encryptedData = ... // post 参数$iv = ... // post 参数$loginInfo = getInfoWithCode($appid, $appsecret, $code);$sessionKey = $loginInfo-&gt;session_key;echo getDecodeEncryptedData($sessionKey, $encryptedData, $iv); 前端拿到openGId后就可以进行绑定相关操作了。 http_post函数，是官方某个demo里的，具体是哪里的忘了： 12345678910111213141516171819function http_post( $url, $data=null ) &#123; $curl = curl_init(); // 启动一个CURL会话 curl_setopt($curl, CURLOPT_URL, $url); // 要访问的地址 curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, false); // 对认证证书来源的检查 curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, false); // 从证书中检查SSL加密算法是否存在 curl_setopt($curl, CURLOPT_USERAGENT, $_SERVER['HTTP_USER_AGENT']); // 模拟用户使用的浏览器 if($data != null)&#123; curl_setopt($curl, CURLOPT_POST, 1); // 发送一个常规的Post请求 curl_setopt($curl, CURLOPT_POSTFIELDS, $data); // Post提交的数据包 &#125; curl_setopt($curl, CURLOPT_TIMEOUT, 300); // 设置超时限制防止死循环 curl_setopt($curl, CURLOPT_HEADER, 0); // 显示返回的Header区域内容 curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1); // 获取的信息以文件流的形式返回 $info = curl_exec($curl); // 执行操作 curl_close( $curl ); // var_dump(json_decode($resp, true)); // echo \"&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;\"; return $info;&#125; 其实这些都可以从官方文档里找到，这里只是做一个总结。 因为我用过框架，上面代码是改变过的，没有进行实际测试，但思路就大概是这样的。 如果代码有什么问题可以告知我。 参考 小程序登录 用户数据的签名验证和加解密","categories":[],"tags":[{"name":"后端","slug":"后端","permalink":"https://tomfriwel.github.io/blog/tags/后端/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://tomfriwel.github.io/blog/tags/微信小程序/"}]},{"title":"微信小程序群功能开发-前端篇","slug":"2018-03-22-develop-wechat-group-miniprogram-front-end","date":"2018-03-22T08:28:49.000Z","updated":"2018-06-21T08:53:11.430Z","comments":true,"path":"2018/03/22/2018-03-22-develop-wechat-group-miniprogram-front-end/","link":"","permalink":"https://tomfriwel.github.io/blog/2018/03/22/2018-03-22-develop-wechat-group-miniprogram-front-end/","excerpt":"","text":"我们在一些微信群中看到过这样的小程序分享卡片：当你点进去后，会看到一个列表，里面有其他群成员的头像和相关信息。比如《王者荣耀群排行》，但是段位信息是腾讯私有的接口，我们只能拿到头像和昵称等基础信息。 下面我将实现小程序端的从转发到用户点击卡片后获取信息的这个过程。 开启首先我们要调用wx.showShareMenu进行设置，来开启是否使用带shareTicket的转发，这个shareTicket是开发群功能的关键: 123wx.showShareMenu(&#123; withShareTicket: true,&#125;) 我一般将其放在页面onShow中。 触发转发事件如果要自定义转发按钮而不是有默认右上角的转发按钮，需要在页面中放置一个open-type=&quot;share&quot;的button组件: 1&lt;button open-type=\"share\"&gt;share&lt;/button&gt; 接下来在页面中设置分享函数onShareAppMessage: 12345678910111213141516171819202122onShareAppMessage: function (res) &#123; if (res.from === 'button') &#123; // 来自页面内转发按钮 console.log(res.target) &#125; return &#123; title: '自定义转发标题', path: '/pages/test/test?id=123', success: function (res) &#123; // 转发成功 console.log(res) // 只有转发到群聊中打开才可以获取到 shareTickets 返回值，单聊没有 shareTickets if (res.shareTickets &amp;&amp; res.shareTickets.length&gt;0) &#123; app.getShareInfo(res.shareTickets[0]) &#125; &#125;, fail: function (res) &#123; // 转发失败 console.log(res) &#125; &#125;&#125; 现在就可以进行转发了，在群聊中将会看到此次分享的小程序消息卡片。每个shareTicket对应每个群并且单聊不会有该值。这里只选择一个转发，所以直接取第一个。至于app.getShareInfo是用来获取群id(openGId)的函数，我们放到后面介绍。 群成员点消息卡片当群成员点消息卡片进入小程序后，在app.js的onShow/onLaunch的options中可以获取到shareTicket，shareTicket每次都是不一样的，比分你分享的时候获取到的跟这里获取到的不是同一个，但是会对应同一个openGId。 app.js: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 在onShow中获取转发信息shareTicketonShow: function (options) &#123; console.log(options) let scene = options.scene // 场景值是1044，带 shareTicket 的小程序消息卡片 if(scene == 1044) &#123; let shareTicket = options.shareTicket // 这里的id根据自己的具体需求进行操作，也可以设置其他的 let id = options.query.id this.getShareInfo(shareTicket) &#125;&#125;,// 获取加密信息encryptedData, ivgetShareInfo: function (shareTicket) &#123; const z = this wx.getShareInfo(&#123; shareTicket: shareTicket, success: function (res) &#123; console.log(res) let &#123;encryptedData, iv&#125; = res if(encryptedData &amp;&amp; iv) &#123; z.getDecodeEncryptedData(encryptedData, iv) &#125; &#125;, fail: function (res) &#123; console.log(res) &#125; &#125;)&#125;,// 获取解密后的信息getDecodeEncryptedData: function (encryptedData, iv) &#123; // 发送到后台解析 wx.login(&#123; success: function(res) &#123; let code = res.code // 下面只是演示代码 // post(&#123; // url:'https://www.example.com/controller/getDecodeEncryptedData' // data:&#123; // code, // encryptedData, // iv, // &#125; // &#125;) &#125; &#125;)&#125;, 首先，我们通过wx.getShareInfo获取encryptedData和iv，然后将其传给后台进行解析。 在getDecodeEncryptedData中，当后台解析成功后，就会返回一个openGId。 此时就可以将群openGId与用户openid进行绑定了，这个绑定信息也是要保存到后台的。如果后台没有保存过头像昵称信息，此时也可以将用户头像和昵称一起保存到后台。 类似于下面这样的一个接口:12345678// 下面只是演示代码post(&#123; url:'https://www.example.com/controller/bindGroupAndUser' data:&#123; code, openGId &#125;&#125;) 其中的code调用wx.login获得，后台根据这个code能获取到openid。然后进行绑定。 然后根据自己的需求，可能还要一个保存用户基础信息和拉取群成员信息列表的接口。 基本思路就是这样，我将在另一篇文章中描述后端的相关处理。 参考 小程序开发文档-转发 小程序登录 用户数据的签名验证和加解密","categories":[],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://tomfriwel.github.io/blog/tags/微信小程序/"}]},{"title":"通过编程来学习线性代数1-解二元线性方程组","slug":"2018-03-21-learn-linear-algebra-by-programming-1","date":"2018-03-21T02:11:47.000Z","updated":"2018-08-14T08:50:35.896Z","comments":true,"path":"2018/03/21/2018-03-21-learn-linear-algebra-by-programming-1/","link":"","permalink":"https://tomfriwel.github.io/blog/2018/03/21/2018-03-21-learn-linear-algebra-by-programming-1/","excerpt":"","text":"环境采用的编程方式是网页，会使用javascript来实现线性代数中的计算方法。比如文件linearAlgebra.html:1234&lt;script&gt; // 在控制台打印 console.log(123*2)&lt;/script&gt; 写入上面的代码，保存后用浏览器打开，然后右键打开审查元素点击控制台（Console）来查看输出。 更多网页相关知识网上可以搜得到，掌握基本javascript编程知识就行了。 解二元线性方程组行列式的概念是由解多元线性方程组而引出的。比如下面这个： \b在坐标系中就是两根直线，分母为零的情况就是两根直线平行不相交。 1. 绘制坐标系下面是我用canvas绘制的坐标系，一般编程中涉及到坐标系的地方，跟数学里有些不同，y轴方向是向下为正。 那么来看看如何绘制出坐标系。下面主要是编程方面的东西，可以自己创建一个.html文件试一试。 首先，创建canvas12345678910111213141516171819&lt;html&gt; &lt;body&gt; &lt;canvas id=\"myCanvas\"&gt;&lt;/canvas&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- Javascript 代码放在标签script里 --&gt;&lt;script type=\"text/javascript\"&gt; // 保存canvas的长宽 var W = 800.0, H = 600.0 // 获取canvas对象 var canvas = document.getElementById('myCanvas') canvas.width = W canvas.height = H // 获取canvas的画布context，我们所有的绘制都将在context上完成。 // 这里也可以传3d，那么context就是一个3d的画布 var ctx = canvas.getContext('2d')&lt;/script&gt; 画布创建好后，接下来着手绘制直角坐标系的两根辅助线。 创建一个函数方便之后的重复调用。 1234567891011121314151617181920212223242526272829// 因为原点是从左上角开始的，为了方便看直线，将原点偏移到指定位置// 每一个设置坐标的地方都要(x + originX, y + originY)var originX = W / 2.0, originY = H / 2.0// 调用函数，传入之前创建好的画布ctxdrawCoordinateSystem(ctx)function drawCoordinateSystem(ctx) &#123; // 设置绘制线的颜色为black ctx.strokeStyle = 'black' // 线宽度 ctx.lineWidth = 1 // 水平线 ctx.beginPath() ctx.moveTo(0, 0 + originY) // 画布的左边界中点 ctx.lineTo(W, 0 + originY) // 画布的右边界中点 ctx.closePath() ctx.stroke() // 垂直线 ctx.beginPath() ctx.moveTo(0 + originX, 0) // 画布的上边界中点 ctx.lineTo(0 + originX, H) // 画布的下边界中点 ctx.closePath() ctx.stroke()&#125; moveTo是设置一个起点，lineTo是将线从上一个点连接到该点。 stroke绘制线条，如果fill\b，那么会将线包围的区域用颜色涂满。途中的黑色三角形方向标就是这样绘制的，设置三个点后调用fill。 调用函数后得到下图： 阴影样式需要给canvas加上一个box-shadow： &lt;canvas id=&quot;myCanvas&quot; style=&quot;box-shadow:1px 1px 10px #666;&quot;&gt;&lt;/canvas&gt; 2. 绘制坐标系刻度和方向标同样，分别创建函数来专门绘制刻度和方向标： 12345678910111213141516171819202122232425262728293031323334353637383940414243// 刻度长度var scaleD= 10.0// 绘制刻度// 传入context和刻度长度function drawScale(ctx, d) &#123; // horizontal for (var x = 0; x &lt; W; x += 50) &#123; ctx.beginPath() ctx.moveTo(x, 0 + originY) ctx.lineTo(x, scaleD + originY) ctx.stroke() ctx.closePath() &#125; // vertical for (var y = 0; y &lt; H; y += 50) &#123; ctx.beginPath() ctx.moveTo(0 + originX, y) ctx.lineTo(scaleD + originX, y) ctx.stroke() ctx.closePath() &#125;&#125;//绘制方向标（三角形），底边长度与底边到顶点长度一样的三角形function drawDirectionArrow(ctx, d) &#123; // horizontal ctx.beginPath() ctx.moveTo(W - d * 2, originY - d) ctx.lineTo(W - d * 2, originY + d) ctx.lineTo(W, originY) ctx.closePath() ctx.fill() // vertical ctx.beginPath() ctx.moveTo(originX - d, H - d * 2) ctx.lineTo(originX + d, H - d * 2) ctx.lineTo(originX, H) ctx.closePath() ctx.fill()&#125; 然后在drawCoordinateSystem函数里追加调用drawScale(ctx, scaleD)和drawDirectionArrow(ctx, scaleD)，运行后如图： 如果想要在刻度上绘制数字标记，可以自行搜索相关文档，有一个叫fillText的函数。 3. 绘制直线a11 * x1 + a12 * x2 = b1 此方程相当于 a * x + b * y = c。 我们可以根据直线方程找到两个点，将两个点通过moveTo和lineTo连接并绘制出来。 12345678910111213141516171819202122232425262728293031//---绘制直线---// 传入直线方程的三个常数和直线颜色/* a * x + b * y = c, 在 x, y 轴上的点 x = 0 &amp;&amp; b != 0, y = c / b =&gt; (0, c / b) y = 0 &amp;&amp; a != 0, x = c / a =&gt; (c / a, 0) b != 0, y = c / b =&gt; (x, (c - a * x) / b) a != 0, x = c / a =&gt; ((c - b * y) / a, y)*/function drawLine(ctx, a, b, c, color = 'red') &#123; // 如果有一个为零，那么直线就是平行于x或y轴的 if (b != 0 &amp;&amp; a != 0) &#123; var x1 = c / a, y1 = 0 // x轴上的点 var x2 = 0, y2 = c / b // y轴上的点 var x3 = -originX, y3 = (c - a * x3) / b //左边界点 var x4 = originX, y4 = (c - a * x4) / b //右边界点 ctx.strokeStyle = color ctx.lineWidth = 1 // 绘制直线 ctx.beginPath() ctx.moveTo(x3 + originX, y3 + originY) ctx.lineTo(x4 + originX, y4 + originY) ctx.closePath() ctx.stroke() &#125;&#125; 然后调用该函数绘制： 12drawLine(ctx, 1, 1, 123, &apos;red&apos;)drawLine(ctx, 1, 5, 999, &apos;blue&apos;) 结果： 4. 求出两直线的交点说了这么多，现在才开始解方程？😤 大多是基础的绘制工作。数学和编程相结合的地方就是如何根据直线方程绘制直线。 对于方程： 12╭ a11*x1 + a12*x2 = b1╰ a21*x1 + a22*x2 = b2 当a11*a22 - a12*a21 != 0时，方程有唯一解：123x1 = (b1*a22 - a12*b2)/(a11*a22 - a12*a21)x2 = (a11*b2 - b1*a21)/(a11*a22 - a12*a21) 1234567891011121314 |a11 a12|D = | | = a11*a22 - a12*a21 //分母 |a21 a22| |b1 a12|D1 = | | = b1*a22 - a1*b2 //x1分子 |b2 a22| |a11 b1|D2 = | | = a11*b2 - b1*a21 //x2分子 |a21 b2|x1 = D1/Dx2 = D2/D 那么我们就可以根据这个来得出两直线相交的点(x1, x2) 下面一个函数是根据两直线的常数计算出交点。第二个函数是在以(x, y)为圆心，半径为10，绘制一个圆 12345678910111213141516171819202122/* a11 &gt; a1 a21 &gt; b1 b1 &gt; c1 ... 计算两直线交点*/function calculateIntersection(a11, a12, b1, a21, a22, b2) &#123; x1 = (b1 * a22 - a12 * b2) / (a11 * a22 - a12 * a21) x2 = (a11 * b2 - b1 * a21) / (a11 * a22 - a12 * a21) return &#123; x: x1, y: x2 &#125;&#125;// 绘制交点function drawIntersection(ctx, x, y) &#123; ctx.arc(x+originX, y+originY, 10, 0, 2*Math.PI) ctx.fill()&#125; 最后，我们的绘制函数大概是这样的： 1234567drawCoordinateSystem(ctx)drawLine(ctx, 1, 1, 123, 'red')drawLine(ctx, 1, 5, 999, 'blue')var p = calculateIntersection(1, 1, 123, 1, 5, 999)drawIntersection(ctx, p.x, p.y) 结果如图： 总结上面求两直线交点的思路是根据二阶行列式来解二元线性方程组。可以看到，行列式是根据解多元线性方程组总结出来的。二阶或三阶行列式我们可以比较轻松的计算出结果，但是随着阶数增加，计算量也会越来越大，n的阶乘（n*n(n-1)*...*3*2*1） 我们来看看求二阶行列式和三阶行列式的值的计算： 1234567891011121314151617181920// 计算二阶行列式的值/*|a11 a12||a21 a22|*/function calculate2Det(a11, a12, a21, a22) &#123; // 2! return a11*a22 - a12*a21&#125;// 计算三阶行列式的值/*|a11 a12 a13||a21 a22 a23||a31 a32 a33|*/function calculate3Det(a11, a12, a13, a21, a22, a23, a31, a32, a33) &#123; // 3! return a11*a22*a33 + a12*a23*a31 + a13*a21*a32 - a13*a22*a31 - a12*a21*a33 - a11*a23*a32&#125; 如果是四阶行列式，那么我们要写4!=24个。所以我们要想办法简化计算，使用一种通用的方式来计算行列式的值，而不是一个一个全部写出来计算。 那么编程上如何简化这个计算呢？ 下一节将会来解决这个问题。 代码 tomfriwel/linearAlgebraPro","categories":[],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://tomfriwel.github.io/blog/tags/基础知识/"},{"name":"线性代数","slug":"线性代数","permalink":"https://tomfriwel.github.io/blog/tags/线性代数/"}]},{"title":"《三块广告牌》","slug":"2018-03-12-Three-Billboards-Outside-Ebbing,-Missouri","date":"2018-03-11T16:00:00.000Z","updated":"2018-06-21T09:51:29.664Z","comments":true,"path":"2018/03/12/2018-03-12-Three-Billboards-Outside-Ebbing,-Missouri/","link":"","permalink":"https://tomfriwel.github.io/blog/2018/03/12/2018-03-12-Three-Billboards-Outside-Ebbing,-Missouri/","excerpt":"","text":"一部充满内容的电影，内容过多的电影往往显得有些沉闷。一部没有结局的电影。 电影一开始的音乐直接暗示了电影的格调。也直接在一开始让观众看到了三块广告牌，点题并让观众产生疑问和兴趣。有什么故事？希望继续看下去。 电影中有大量语言对峙，每个对话都能让人感觉到对话人之间的内心活动和冲撞。 女主一开始的表情是迷茫，看到三块广告牌后若有所思，最后下定决心开车离开。这个过程没有一句话只有音乐，但你能从女主的表情和眼神很明显感觉到她的内心活动。 其中有一段对话，一个人以自己得了癌症这件事来暗示对方做事，大概就是“我都得了癌症了，你就不能怎么怎么吗？”。一般一个人得了癌症后让你做什么事你都难以拒绝，但是女主并没有，反而听到这个消息后很平淡说了一句“我知道啊”，言下之意“那又怎么样？”。这时对方泄气。 还有很多这种对话，能让人感觉到比武打片还激烈。各种不按常理出牌，剧情转折。 还有一些有教育意义事。比如大人在小孩面前表现出一些陋习，孩子长大后有了这些陋习后，你教育你的孩子，她会以你以前也这样来反驳，这就是你教的。“Children see Children do” 但是同样也有一个人带着陋习长大后，因为某些事发生了改变，但这个改变并不简单。因为那个得了癌症的人死后留给他的信，引发了他的思想的改变。 人小时候很善于学习和模仿，养成习惯后，要改变往往是被动的，需要导火索，并不是一两句劝诫的话就能改变的。上学的时候老师讲了很多的道理，你现在还能记住几句？就像我初中数学老师说过的那样，很多年以后你可能已经忘了我教你的知识、讲过的道理，但是你还能记得哪个老师有哪些习惯、有哪些惯用语。就像我现在还记得高中数学老师批评一个人的时候会说：“我批评的是你这种行为，而不是你这个人”。 电影最后没有结局，以两个人相互问对方做结尾，“我们路上再想吧”。","categories":[],"tags":[{"name":"电影","slug":"电影","permalink":"https://tomfriwel.github.io/blog/tags/电影/"}]},{"title":"通过编程来学习基础学科的知识","slug":"2018-03-11-learn-basic-knowledge-by-programming","date":"2018-03-10T16:00:00.000Z","updated":"2018-06-21T09:52:08.730Z","comments":true,"path":"2018/03/11/2018-03-11-learn-basic-knowledge-by-programming/","link":"","permalink":"https://tomfriwel.github.io/blog/2018/03/11/2018-03-11-learn-basic-knowledge-by-programming/","excerpt":"","text":"我希望学习基础学科的时候，能够与其他领域的技术相结合来学习，而不是一味地做练习题。做练习是必要的，熟能生巧，但是也应该学习去创造去思考，不要成为一个书呆子。更希望人们看到基础学科在实际生活中的应用，也希望将基础知识和其他领域的知识相结合，就像现在互联网与其他领域结合一样。 餐厅饭店借助互联网技术让点餐更方便，通过评分体系让人们了解商家商品。还有现在的人工智能，帮助商家分析用户喜好，给用户提供更好的服务。 又比如《我的世界》做出各种有趣的东西，游戏当中提供各种基础的材料，玩家发挥各种脑洞。 我一些基础知识学得并不好，大学期间花太多时间在游戏上了，所以我打算尝试通过编程的方式来学习一些基础科学的知识。 目前计划学习的是线性代数，之后可能会有物理相关的。 最后，喜欢那些玩游戏笑得开心的人，他们真的是在享受游戏。","categories":[],"tags":[{"name":"思考","slug":"思考","permalink":"https://tomfriwel.github.io/blog/tags/思考/"}]},{"title":"微信小程序：截图组件welCropper，实现原理及其使用","slug":"微信小程序：截图组件welCropper，实现原理及其使用","date":"2018-01-26T02:23:00.000Z","updated":"2018-09-18T08:47:01.900Z","comments":true,"path":"2018/01/26/微信小程序：截图组件welCropper，实现原理及其使用/","link":"","permalink":"https://tomfriwel.github.io/blog/2018/01/26/微信小程序：截图组件welCropper，实现原理及其使用/","excerpt":"","text":"最近做项目的时候，需要做一个截图功能。用了一个别人写的截图工具，发现截出的图质量下降了，但是我们图片要用来做识别, 需要保证截出的图质量不下降。而且也不支持通过拖动来调整截图框的大小。所以这个截图工具无法满足需求。因为所以，就自己动手写了一个截图组件。 下面介绍一下实现原理和使用方法。 实现原理组件wxml的层次结构图如下： original canvas 用来绘制原图大小的图片，这样能保证截图后的质量不会下降，这个canvas是隐藏的。 movable-area是movable-view的容器，是官方提供的拖拽移动组件，用来移动截取框的四个角。这个组件支持多个点同时移动。 scale canvas用来绘制适应屏幕比例大小的图片（aspectFit），因为通常原图大小是超过屏幕长宽的。（一开始白线框和图片都在这一层，但后来发现每次移动都要绘制一次图片，这样会造成卡顿、性能下降。所以就想到通过增加一个move canvas来专门绘制白线框来降低绘制图片带来的资源消耗，因为图片是静止的，不需要重复绘制。） move canvas是根据四个movable-view的位置绘制出截图框。 最后截图，通过四个点的位置计算出截图框的位置，然后放大对应原图大小的位置，得到在原图中的(x, y, width, height)，最后通过官方提供的canvas接口截图。1234567891011wx.canvasToTempFilePath(&#123; x: x, y: y, width: w, height: h, destWidth: w, destHeight: h, canvasId: &apos;originalCanvas&apos;, success: function (res) &#123; &#125;)&#125; 旋转原理 特点 保证截图质量不会被压缩（也可以选择压缩图） 截图框能够通过拖拽四个角来调整选区大小 使用假设我们的应用文件结构如下：123456789101112131415./├── app.js├── app.json├── app.wxss├── pages│ └── index│ ├── index.js│ ├── index.json│ ├── index.wxml│ └── index.wxss└── welCropper ├── welCropper.js ├── welCropper.wxml └── welCropper.wxss 调用组件时，需要传入cropperData、cropperMovableItems、cropperChangableData，因为数据和事件都是绑定在Page上的，所以要避免使用组件里面已经被占用的命名。/pages/index/index.wxml12345678&lt;!-- 引入组件 --&gt;&lt;import src=&quot;/welCropper/welCropper.wxml&quot; /&gt;&lt;!-- 调用组件 --&gt;&lt;template is=&quot;welCropper&quot; data=&quot;&#123;&#123;data:cropperData, cropperMovableItems:cropperMovableItems, cropperChangableData:cropperChangableData&#125;&#125;&quot;&gt;&lt;/template&gt;&lt;!-- 用于选择图片，传入cropper中 --&gt;&lt;button bindtap=&apos;selectTap&apos;&gt;select image&lt;/button&gt; /pages/index/index.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 获取显示区域长宽const device = wx.getSystemInfoSync()const W = device.windowWidthconst H = device.windowHeight - 50let cropper = require(&apos;../../welCropper/welCropper.js&apos;);console.log(device)Page(&#123; data: &#123; &#125;, onLoad: function () &#123; var that = this // 初始化组件数据和绑定事件 cropper.init.apply(that, [W, H]); &#125;, selectTap() &#123; var that = this wx.chooseImage(&#123; count: 1, // 默认9 sizeType: [&apos;original&apos;, &apos;compressed&apos;], // 可以指定是原图还是压缩图，默认二者都有 sourceType: [&apos;album&apos;, &apos;camera&apos;], // 可以指定来源是相册还是相机，默认二者都有 success(res) &#123; const tempFilePath = res.tempFilePaths[0] console.log(tempFilePath) // 将选取图片传入cropper，并显示cropper // mode=rectangle 返回图片path // mode=quadrangle 返回4个点的坐标，并不返回图片。这个模式需要配合后台使用，用于perspective correction let modes = [&quot;rectangle&quot;, &quot;quadrangle&quot;] let mode = modes[0] //rectangle, quadrangle that.showCropper(&#123; src: tempFilePath, mode: mode, sizeType: [&apos;original&apos;, &apos;compressed&apos;], //&apos;original&apos;(default) | &apos;compressed&apos; callback: (res) =&gt; &#123; if (mode == &apos;rectangle&apos;) &#123; console.log(&quot;crop callback:&quot; + res) wx.previewImage(&#123; current: &apos;&apos;, urls: [res] &#125;) &#125; else &#123; wx.showModal(&#123; title: &apos;&apos;, content: JSON.stringify(res), &#125;) console.log(res) &#125; // that.hideCropper() //隐藏，我在项目里是点击完成就上传，所以如果回调是上传，那么隐藏掉就行了，不用previewImage &#125; &#125;) &#125; &#125;) &#125;&#125;) 最后引入组件的样式/pages/index/index.wxss1@import &quot;/welCropper/welCropper.wxss&quot;; 注意 因为wx.canvasToTempFilePath输出的是.png图片，截出来的图有可能远远大于原图（比如3通道图变成4通道的图） 源代码 Github:tomfriwel/welCropper，将welCropper文件夹复制到自己项目，引入调用就行了。 wepy 版本：github: callmesoul/wepy-corpper 如果出现什么bug、问题或者建议可以告诉我，我会尽量改进。效果图 如果将movable-view显示出来是这样的：","categories":[],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://tomfriwel.github.io/blog/tags/微信小程序/"},{"name":"前端","slug":"前端","permalink":"https://tomfriwel.github.io/blog/tags/前端/"},{"name":"开源项目","slug":"开源项目","permalink":"https://tomfriwel.github.io/blog/tags/开源项目/"}]},{"title":"微信小程生成二维码工具weapp-qrcode.js","slug":"微信小程生成二维码工具weapp-qrcode-js","date":"2018-01-02T13:07:00.000Z","updated":"2018-09-18T08:47:11.457Z","comments":true,"path":"2018/01/02/微信小程生成二维码工具weapp-qrcode-js/","link":"","permalink":"https://tomfriwel.github.io/blog/2018/01/02/微信小程生成二维码工具weapp-qrcode-js/","excerpt":"","text":"weapp-qrcode微信小程序生成二维码工具 生成二维码数据的主要代码来自davidshimjs/qrcodejs，因为它这个里面生成二维码图片的功能在微信小程序里不能使用，我将这个功能改写成可以在微信小程序中使用。 截图 使用页面js中引入:1var QRCode = require(&apos;../../utils/weapp-qrcode.js&apos;) 页面加载好后:12345678var qrcode = new QRCode(&apos;canvas&apos;, &#123; text: &quot;https://github.com/tomfriwel/weapp-qrcode&quot;, width: 150, height: 150, colorDark: &quot;#000000&quot;, colorLight: &quot;#ffffff&quot;, correctLevel: QRCode.CorrectLevel.H,&#125;); text为需要转化为二维码的字符串； width和height为绘制出的二维码长宽，这里设置为跟canvas同样的长宽； colorDark和colorLight为二维码交替的两种颜色； correctLevel没有细看源码，命名上看应该是准确度； 如果需要再次生成二维码，调用qrcode.makeCode(&#39;text you want convert&#39;)。 主要流程 源代码tomfriwel/weapp-qrcode","categories":[],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://tomfriwel.github.io/blog/tags/微信小程序/"},{"name":"前端","slug":"前端","permalink":"https://tomfriwel.github.io/blog/tags/前端/"},{"name":"开源项目","slug":"开源项目","permalink":"https://tomfriwel.github.io/blog/tags/开源项目/"}]},{"title":"记一次VUE开发环境搭建","slug":"setup-vue-development-environment-first-time","date":"2017-12-10T20:47:00.000Z","updated":"2018-08-17T09:29:17.925Z","comments":true,"path":"2017/12/11/setup-vue-development-environment-first-time/","link":"","permalink":"https://tomfriwel.github.io/blog/2017/12/11/setup-vue-development-environment-first-time/","excerpt":"","text":"今天想了解一下vue开发相关的东西，就动手搭建了一些开发环境。下面是我安装和配置的相关过程。（Mac系统） 下载安装nodejs 6.11.4 (包含 npm 3.10.10) 安装完成后，命令行升级一下npm123$ npm install npm@latest -g$ npm -v5.5.1 权限设置123$ npm config get prefix/usr/local$ sudo chown -R $(whoami) $(npm config get prefix)/&#123;lib/node_modules,bin,share&#125; npm config get prefix是用来找到npm的目录sudo chown -R $(whoami) $(npm config get prefix)/{lib/node_modules,bin,share}给当前用户读写npm相关目录的权限。 安装webpack和vue-cli12345678910$ npm install webpack -g$ npm install vue-cli -g$ npm list -g --depth=0/usr/local/lib├── create-react-native-app@1.0.0├── es-checker@1.4.1├── npm@5.5.1├── vue-cli@2.9.1└── webpack@3.8.1 创建工程12$ cd your_workspace_folder$ vue init webpack projectname 比如我的工程名为vueStart，输入的地方没有什么需求直接回车就行了。 1234567891011121314$ vue init webpack-simple vueStart? Project name vuestart? Project description A Vue.js project? Author tomfriwel &lt;xxx@xx.com&gt;? Use sass? No vue-cli · Generated &quot;vueStart&quot;. To get started: cd vueStart npm install npm run dev. 这里注意的是，如果用vue init webpack-simple projectname，之后npm run dev是运不起来的。所以这里用的webpack而不是webpack-simple 这里的vue init webpack和npm install webpack不一样 vue init webpack是安装webpack模板（也可以是以下列出的一些模板webpack-simple/browserify...）具体信息可以查看vuejs-templates/webpack 一些可用的模板 webpack - A full-featured Webpack + vue-loader setup with hot reload, linting, testing &amp; css extraction. webpack-simple - A simple Webpack + vue-loader setup for quick prototyping. browserify - A full-featured Browserify + vueify setup with hot-reload, linting &amp; unit testing. browserify-simple - A simple Browserify + vueify setup for quick prototyping. pwa - PWA template for vue-cli based on the webpack template simple - The simplest possible Vue setup in a single HTML file 配置工程进入创建的工程目录12$ cd vueStart/$ npm install npm install后就会安装一些乱七八糟的东西。 安装 vue 路由模块vue-router和网络请求模块vue-resource，这两个如果用不到也可以不用装。1234$ npm install vue-router vue-resource --save+ vue-resource@1.3.4+ vue-router@3.0.1added 17 packages in 6.541s --save的作用 运行和构建1$ npm run dev 没什么问题的话，打开页面是这样的 对.vue更改后，页面也会自动更新，挺方便的。 开始编写src文件夹目录1234567src├── App.vue├── assets│ └── logo.png├── components│ └── HelloWorld.vue└── main.js 这里App.vue引用了一个叫HelloWorld的组件。我们对HelloWorld组件进行更改。12345678910&lt;script&gt;export default &#123; name: &apos;HelloWorld&apos;, data () &#123; return &#123; msg: &apos;First modify.&apos; &#125; &#125;&#125;&lt;/script&gt; 保存后 发布执行1$ npm run build 完成后会生成一个dist文件夹123456789101112dist├── index.html└── static ├── css │ └── app.86d25fd679f2d9f5bee9162ae7804b46.css └── js ├── app.bcbf2665a80fe0bdc316.js ├── app.bcbf2665a80fe0bdc316.js.map ├── manifest.f9cc8df0a9bc12617260.js ├── manifest.f9cc8df0a9bc12617260.js.map ├── vendor.5edf78e409459ac3ccd1.js └── vendor.5edf78e409459ac3ccd1.js.map 如果是想本地运行而不是放到服务器上，需要对config/index.js进行一个小更改。将build中的assetsPublicPath改为./，不然会找不到资源，最后再次npm run build，就可以直接浏览器打开dist文件夹下的index.html了。 123456789101112...module.exports = &#123; build: &#123; env: require(&apos;./prod.env&apos;), index: path.resolve(__dirname, &apos;../dist/index.html&apos;), assetsRoot: path.resolve(__dirname, &apos;../dist&apos;), assetsSubDirectory: &apos;static&apos;, assetsPublicPath: &apos;./&apos;, productionSourceMap: true,... Tipsnpm run build和npm run dev其实是运行的package.json里scripts的对应的脚本。例如我的123456789 ...&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;node build/dev-server.js&quot;, &quot;start&quot;: &quot;npm run dev&quot;, &quot;build&quot;: &quot;node build/build.js&quot; &#125;, ... 可以自己测试一个12345678910 ...&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;node build/dev-server.js&quot;, &quot;start&quot;: &quot;npm run dev&quot;, &quot;build&quot;: &quot;node build/build.js&quot;, &quot;test&quot;: &quot;echo 123&quot; &#125;, ... 然后运行npm run test看看结果。 相关参考Installing Node.js and updating npmFixing npm permissionsVue2.0 新手完全填坑攻略——从环境搭建到发布What is the –save option for npm install?Vue 爬坑之路（一）—— 使用 vue-cli 搭建项目基于vue-cli快速构建npm scripts 使用指南vuejs/vue-cli","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://tomfriwel.github.io/blog/tags/Vue/"}]}]}